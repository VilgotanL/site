char* OS_NAME = "SubleqOS";
char* OS_VERSION = "v0.0.1";

int* BLUESCREEN = NULL;
int* BLUESCREEN_DATA_STR = NULL; // not malloc'd
void* os_log = NULL;

// TYPES:
// const - the func explicitly does not modify the argument (example: const char*)
// mallocated - the func takes ownership of the malloc'd argument


// TODO: make compilers from subleq to other langs so subleqos can run anywhere


inline void true_write(char* str) for(int i=0; i<len(str); i++) true_io_putch str[i];
inline void true_print(char* str) { true_write(str); true_io_putch '\n'; }

inline void memset(int* ptr, int val, int length) {
    asm {
        negVal negVal ?+1 val negVal ?+1
        A A ?+1 B B ?+1 C C ?+1
        negPtr negPtr ?+1 ptr negPtr ?+1
        negPtr A ?+1 negPtr B ?+1 negPtr C ?+1
        @-1 length ?+1
        
        check:
        @1 length after
        A:? B:? ?+1
        negVal C:? ?+1
        @-1 A ?+1 @-1 B ?+1 @-1 C ?+1
        @0 @0 check
        
        negVal:? negPtr:? after:
    }
}
inline void memcopy(int* src, int length, int* dest) { // TODO implement in asm
    for(int i=0; i<length; i++)
        dest[i] = src[i];
}
inline bool streq(int* a, int* b) { // TODO implement in asm?
    if(len(a) != len(b)) return 0;
    for(int i=0; i<len(a); i++) if(a[i] != b[i]) return 0;
    return 1;
}
int* malloc(int size) {
    return true_malloc(size);
}
void free(int* ptr) {
    true_free(ptr);
}
int* load(int* dynf) {
    int* p = malloc(len(dynf));
    
    int asmLoopVar = len(dynf)+1;
    int addBy = p-dynf;
    int negPtr = -p; int negOrig = -dynf;
    asm {
        p1 p1 ?+1 p2 p2 ?+1 p3 p3 ?+1 pOrig pOrig ?+1
        negPtr p1 ?+1 negPtr p2 ?+1 negPtr p3 ?+1 negOrig pOrig ?+1
        check:
        @1 asmLoopVar after
        p1:? p2:? ?+1
        val val ?+1
        pOrig:? val ?+1
        addBy val ?+1
        val p3:? ?+1
        @-1 p1 ?+1 @-1 p2 ?+1 @-1 p3 ?+1 @-1 pOrig ?+1
        @0 @0 check
        val:?
        after:
    }
    return p;
}
void unload(int* p) {
    free(p);
}
char* _itoa_nomalloc_with_buff(int i, int* arr) {
    if(i == 0) return "0";
    int negative = i < 0;
    if(negative) i = -i;
    int* ptr = arr+len(arr)-1;
    int* start;
    
    int mult = 1;
    while(mult <= i) {
        *ptr = mult;
        ptr--;
        mult = mult+mult+mult+mult+mult;
        mult = mult+mult;
        if(ptr <= arr+1) return "(big)";
    }
    if(negative) { *ptr = '-'; start = ptr; }
    else { start = ptr+1; }
    ptr++;
    
    while(ptr < arr+len(arr)) {
        int digit = 0;
        while(i >= 0) {
            i -= *ptr;
            digit++;
        }
        i += *ptr;
        digit--;
        *ptr = '0'+digit;
        ptr++;
    }
    *(start-1) = arr+len(arr)-start;
    return start;
}
inline char* itoa_no_malloc(int i) {
    int* arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    return _itoa_nomalloc_with_buff(i, arr);
}
static int* clone(const int* p) {
    int* p2 = malloc(len(p));
    memcopy(p, len(p), p2);
    return p2;
}
static void appendint(int** ptrToVar, void value) {
    int* newArr = malloc(len(*ptrToVar)+1);
    memcopy(*ptrToVar, len(*ptrToVar), newArr);
    newArr[len(*ptrToVar)] = value;
    free(*ptrToVar);
    *ptrToVar = newArr;
}

inline void _assert_mallocd_is_zerolen(const int* p) { // ASSUMPTIOUS
    if(malloc(0) >= program_end_addr) BLUESCREEN("_assert_mallocd_is_zerolen assumption broken");
    return p == malloc(0);
}
inline void assert_mallocd(const int* p, char* msg) {
    if(p < program_end_addr && !_assert_mallocd_is_zerolen(p)) { // _assert_mallocd_is_zerolen allows malloc(0) through since malloc(0) gives a pointer to litref(0)+1
        BLUESCREEN_DATA_STR = msg;
        BLUESCREEN("assert_mallocd failed");
    }
}



// === STREAMS ===

static int* new_stream(void callWhenEmpty) {
    int* stream = malloc(3);
    stream[0] = 0; // bool stoppedSending (eof but sender has stopped sending, but chunks can still exist)
    stream[1] = NULL; // ptr to chunk linked list
    stream[2] = callWhenEmpty; // example: cmd-line input provides this to read a line
    return stream;
}
static int* stream_recv(int* stream) { // returns null when no more rn or malloc that needs freeing
    assert_mallocd(stream, "srecv");
    if(!stream[0] && !stream[1] && stream[2]) stream[2](); // call callWhenEmpty
    if(stream[1]) {
        int* cell = stream[1];
        stream[1] = cell[1];
        int* str = cell[0];
        free(cell);
        return str;
    } else return NULL;
}
inline bool stream_isEof(int* stream) {
    assert_mallocd(stream, "sIsEof");
    return stream[0] && !stream[1];
}
inline bool stream_isFlush(int* stream) {
    assert_mallocd(stream, "sflush");
    return !stream[1];
}
inline bool stream_finish(int* stream) {
    assert_mallocd(stream, "sfinish");
    stream[0] = 1;
}
static void stream_send(int* stream, int* allocdData) {
    assert_mallocd(stream, "ssenda");
    assert_mallocd(allocdData, "ssendb");
    if(stream[0]) BLUESCREEN("stream_send when stream finished");
    if(len(allocdData) <= 0) BLUESCREEN("stream_send: data must have positive length");
    int* p = stream;
    while(p[1]) {
        p = p[1];
    }
    p[1] = malloc(2);
    p[1][0] = allocdData;
    p[1][1] = NULL;
}
static void free_stream(int* stream) { // frees the data too
    assert_mallocd(stream, "sfree");
    if(!stream[0]) BLUESCREEN("stream must be stream_finish:ed before freeing");
    int* p = stream[1];
    free(stream);
    while(p) {
        int nextP = p[1];
        free(p[0]);
        free(p);
        p = nextP;
    }
}



// === FILE SYSTEM ===
int** fs_root = static_ints { 0 };


static int* fs_mkFile(mallocated char* allocdName, mallocated int* allocdData, int* adjacentChild) {
    assert_mallocd(allocdName, "mkfile1"); assert_mallocd(allocdData, "mkfile2");
    int* file = malloc(5);
    file[0] = NULL; // parent
    file[1] = 'f'; // type: file
    file[2] = allocdName;
    file[3] = allocdData;
    file[4] = adjacentChild;
    return file;
}
static int* fs_mkFolder(mallocated char* allocdName, int* firstChild, int* adjacentChild) {
    assert_mallocd(allocdName, "mkfolder");
    int* folder = malloc(5);
    folder[0] = NULL; // parent
    folder[1] = 'D'; // type: folder (Dir)
    folder[2] = allocdName;
    folder[3] = firstChild; // first child
    folder[4] = adjacentChild; // next adjacent child
    if(firstChild) firstChild[0] = folder;
    if(firstChild && firstChild[4]) { // one time i had a major and difficult bug here where i just forgot to check firstChild before checking firstChild[4]
        // the bug caused random parts of the code to be modified leading to unrelated code erroring, this is the nature of the undefined behaviour of such bugs
        int* child = firstChild[4];
        while(child) {
            child[0] = folder;
            child = child[4];
        }
    }
    return folder;
}
// files with the same name aren't supposed to exist in same folder but fs_invalidName doesnt check that
// TODO make command to check if file name is valid
static bool fs_invalidName(const char* name) { // returns 0 (false) or not allocated error string literal
    if(len(name) == 0) return "File or folder name is empty";
    for(int i=0; i<len(name); i++) {
        char ch = name[i];
        if(ch < 32) return "File or folder name contains control character (ch<32)";
        if(ch == '/') return "File or folder name contains /";
        if(ch == '\\') return "File or folder name contains \\";
    }
    if(name[0] == ' ' || name[len(name)-1] == ' ') return "File or folder name starts or ends with a space";
    bool allDots = 1;
    for(int i=0; i<len(name); i++) {
        if(name[i] != '.') allDots = 0;
    }
    if(allDots) return "File or folder name contains only dots";
    return 0;
}

int* fs_get_err = NULL;
static int* fs_get(const char* path, int* maybeRelativeTo) { // returns NULL (and then sets fs_get_err) or fs object (and sets fs_get_err=NULL), does not free path or cwd, maybeRelativeTo is fs obj
    fs_get_err = NULL;
    inline int* err(char* str) {
        fs_get_err = str;
        return NULL;
    }
    if(!*fs_root) return err("File system does not exist");
    if(len(path) == 0) return err("Empty path");
    
    int* curr = NULL;
    int i = 0;
    if(path[0] == '/') { curr = *fs_root; i++; }
    else {
        if(!maybeRelativeTo) return err("Path must be absolute (no relative-to specified)");
        assert_mallocd(maybeRelativeTo, "fsget.mayberelativeto");
        if(maybeRelativeTo[1] != 'D') return err("Relative-to must be a folder");
        curr = maybeRelativeTo;
    }
    if(!curr) BLUESCREEN("fs_get no curr");
    while(i < len(path)) {
        int end = i;
        while(end < len(path) && path[end] != '/') end++;
        int* name = malloc(end-i);
        memcopy(path+i, end-i, name);
        
        if(len(name) == 1 && name[0] == '.') {
            curr = curr;
        } else if(len(name) == 2 && name[0] == '.' && name[1] == '.') {
            curr = curr[0] || curr; // parent or itself if no parent
        } else {
            char* invalidErr = fs_invalidName(name);
            if(invalidErr) { free(name); return err(invalidErr); }
            if(curr[1] != 'D') { free(name); return err("Can't get file inside file"); }
            
            int* currChild = curr[3];
            while(currChild && !streq(currChild[2], name))
                currChild = currChild[4];
            
            if(!currChild) { free(name); return err("File or folder not found"); }
            else curr = currChild;
        }
        free(name);
        i = end+1; // skip the /, and a dangling / is fine at end of path
    }
    return curr;
}


static void fs_init() {
    if(!*fs_root) {
        os_log("fs_init: Building file system.\n");
        *fs_root = fs_mkFolder(clone(""),
            fs_mkFolder(clone("bin"),
                fs_mkFile(clone("filetest.txt"), clone("hi"),
                fs_mkFile(clone("filetest2.txt"), clone("hello"), NULL)),
            fs_mkFolder(clone("user"), NULL, NULL)),
        NULL);
        os_log("fs_init: FS build success\n");
    } else {
        os_log("fs_init: File system exists.\n");
    }
}



// TODO make this more attached to procs?
// === ENV TABLE ===
// Entry types:
// 0 - Mallocd String
// 1 - Number
// 2 - Const Function
int* global_envtable = NULL;
static int* new_envtable() {
    int* t = malloc(2);
    t[0] = NULL; // Parent
    t[1] = NULL; // Linked list of cells with { mallocdKey, entryType, value, next }
    return t;
}
static void envtable_set(int* t, const char* key, int type, void value) {
    assert_mallocd(t, "envtableset");
    int* p = (t+1);
    while(*p && !streq((*p)[0], key)) {
        p = (*p)+3;
    }
    if(!*p) *p = malloc(4);
    int cell = *p;
    cell[0] = clone(key);
    cell[1] = type;
    cell[2] = value;
    cell[3] = NULL; // next
}
static void envtable_get(int* table, const char* key) { // returns ptr to cell or NULL
    assert_mallocd(table, "envtableget");
    int* t = table;
    while(t) { // TODO test parent walking mechanism
        int* cell = t[1];
        while(cell) {
            if(streq(cell[0], key)) return cell;
            cell = cell[3];
        }
        t = t[0];
    }
    return NULL;
}
static void _envtable_free_cell(int* cell) {
    assert_mallocd(cell, "_envtablefreecell");
    free(cell[0]);
    if(cell[1] == 0) { // Malloc'd string
        free(cell[2]);
    } else if(cell[1] == 1 || cell[1] == 2) {
        //pass
    } else BLUESCREEN("_envtable_free_cell: unknown/unimplemented cell type");
    free(cell);
}
static bool envtable_remove(int* t, const char* key) { // removes key if exists and returns if it existed
    assert_mallocd(t, "envtableremove");
    int* addr = (t+1);
    while(*addr) {
        if(streq((*addr)[0], key)) {
            int* cell = *addr;
            *addr = cell[3];
            // clean up the cell
            _envtable_free_cell(cell);
            return 1;
        }
        addr = (*addr)+3;
    }
    return 0;
}
static void free_envtable(int* t) {
    assert_mallocd(t, "freeenvtable");
    // TODO
    // TODO redirect children to parent
    BLUESCREEN("TODO");
}

static void env_init_global() {
    global_envtable = new_envtable();
    
    envtable_set(global_envtable, "OS_NAME", 0, clone(OS_NAME));
    envtable_set(global_envtable, "OS_VERSION", 0, clone(OS_VERSION));
    envtable_set(global_envtable, "CWD", 0, "/");
    envtable_set(global_envtable, "numtest", 1, 1234);
    static void f() {
        //pass
    }
    envtable_set(global_envtable, "functest", 2, f);
}



// === PROCESSES ===

int* processes = NULL; // linked list

int _proc_loop_return_to = NULL;
static void new_process(mallocated char* allocdName) { // The caller of this takes care of stream finish and cleanup, but the process loop frees the other stuff
    assert_mallocd(allocdName, "newproc");
    int* proc = malloc(9);
    proc[0] = allocdName;
    proc[1] = NULL; // continue_at_addr
    proc[2] = 0; // proc_should_exit, proc exits by setting proc[1] to null and can be done without exit being requested (proc_should_exit would ==0 when not requested)
    proc[3] = NULL; // stdin (from proc perspective), maybe null
    proc[4] = NULL; // stdout (from proc perspective), maybe null
    proc[5] = NULL; // stderr (from proc perspective), maybe null
    proc[6] = 0; // retcode (<=0 is success)
    proc[7] = NULL; // execOnExitBeforeUnload(int* proc), maybe null
    proc[8] = NULL; // env table (TODO)
    return proc;
}
static void add_process(int* process) {
    assert_mallocd(process, "addproc");
    int *p = &processes;
    while(*p) {
        p = (*p)+1;
    }
    int* newCell = malloc(2);
    *p = newCell;
    newCell[0] = process;
    newCell[1] = NULL;
}
inline void process_wait(int* process) {
    assert_mallocd(process, "procwait");
    process[1] = returnlbl;
    jmp _proc_loop_return_to;
    returnlbl:
}
inline void process_exit(int* process) {
    assert_mallocd(process, "procexit");
    process[1] = NULL;
    jmp _proc_loop_return_to;
}

static void PROCESS_LOOP() {
    os_log("process loop: Starting process loop\n");
    int* curr_proc_cell_addr = &processes;
    while(*curr_proc_cell_addr != NULL) {
        
        _proc_loop_return_to = return_to;
        int* proc = (*curr_proc_cell_addr)[0];
        assert_mallocd(proc, "procloop");
        
        int* next_proc_cell_addr = (*curr_proc_cell_addr)+1;
        
        if(proc[1]) {
            jmp proc[1];
        } else {
            if(proc[7]) proc[7](proc);
            if(proc[8]) BLUESCREEN("env table cleanup not implemented");
            free(proc[0]);
            free(proc);
            // now remove and free cell
            int* cell = *curr_proc_cell_addr;
            *curr_proc_cell_addr = *next_proc_cell_addr;
            free(cell);
        }
        return_to:
        
        if(!*next_proc_cell_addr) next_proc_cell_addr = &processes;
        curr_proc_cell_addr = next_proc_cell_addr;
    }
    os_log("process loop: No processes left, shutting down...\n");
}



// === PROGRAMS ===


dynamic void spawnShell(int* proc) { // the process will be the shell
    assert_mallocd(proc, "spawnshell");
    proc[1] = startLbl;
    return 0; // TODO change to empty return
    startLbl:
    int* stdIn = proc[3];
    int* stdOut = proc[4];
    int* env = proc[8];
    if(!stdIn) BLUESCREEN("Shell requires stdin");
    if(!stdOut) BLUESCREEN("Shell requires stdout");
    if(!env) BLUESCREEN("Shell requires env table");
    int exitCode = 0; // code the shell will exit with
    
    // getch
    int* lastChunk = NULL;
    int lastChunkI = 0;
    static char getch() {
        if(lastChunk && lastChunkI < len(lastChunk)) {
            char ch = lastChunk[lastChunkI];
            lastChunkI++;
            return ch;
        }
        if(lastChunk) {
            free(lastChunk);
            lastChunk = NULL;
        }
        while(!lastChunk) { // TODO process EOF
            process_wait(proc);
            lastChunk = stream_recv(stdIn);
        }
        char ch = lastChunk[0];
        lastChunkI = 1;
        return ch;
    }
    static int write(char* str) { // does not free str
        if(len(str) > 0)
            stream_send(stdOut, clone(str));
    }
    
    int* cmds;
    
    // = COMMANDS =
    static void cmd_help(int* args) {
        write("-- Commands --\n");
        for(int i=0; i<len(cmds); i++) {
            write(cmds[i][0]);
            for(int j=len(cmds[i][0]); j<12; j++) write(" ");
            write(cmds[i][2]); write("\n");
        }
        for(int i=0; i<len(args); i++)
            free(args[i]);
        free(args);
    }
    static void cmd_echo(int* args) {
        for(int i=1; i<len(args); i++) {
            write(args[i]);
            if(i < len(args)-1) write(" ");
            free(args[i]);
        }
        free(args[0]);
        free(args);
    }
    static void cmd_tree(int* args) {
        for(int i=0; i<len(args); i++)
            free(args[i]);
        free(args);
        
        int depth = 0;
        int* p = *fs_root;
        while(p) {
            for(int i=0; i<depth; i++) write("  ");
            write(p[2]);
            if(p[1] == 'D') write("/");
            write("\n");
            if(p[1] == 'D' && p[3]) { // direct child
                depth++;
                p = p[3];
            } else if(p[4]) { // adjacent child
                p = p[4];
            } else { // go to parent with adjacent child
                while(p) {
                    p = p[0];
                    depth--;
                    if(p && p[4]) {
                        p = p[4];
                        break;
                    }
                }
            }
        }
    }
    static void cmd_exit(int* args) {
        for(int i=0; i<len(args); i++)
            free(args[i]);
        free(args);
        exitCode = 0;
        jmp CLEANUP;
    }
    static void cmd_processes(int* args) {
        for(int i=0; i<len(args); i++)
            free(args[i]);
        write("Active processes:\n");
        int p = processes;
        while(p) {
            int* proc = p[0];
            write("  "); write(proc[0]); write("\n");
            p = p[1];
        }
    }
    static void cmd_set(int* args) {
        if(len(args) > 1) BLUESCREEN("cmd_set TODO");
        for(int i=0; i<len(args); i++)
            free(args[i]);
        int* t = env;
        int* tables = malloc(0);
        while(t) {
            appendint(&tables, t);
            t = t[0];
        }
        for(int i=len(tables)-1; i>=0; i--) {
            int* t = tables[i];
            write("Env table:\n");
            int* p = t[1];
            while(p) {
                int type = p[1];
                write(" ");
                write(type == 0 ? "str" : type == 1 ? "int" : type == 2 ? "fun" : "???");
                write(" '"); write(p[0]); write("'\n");
                p = p[3];
            }
        }
        free(tables);
    }
    
    cmds = {
        {"help", cmd_help, "Displays list of commands"},
        {"echo", cmd_echo, "Prints arguments to the screen"},
        {"exit", cmd_exit, "Exits the shell"},
        {"tree", cmd_tree, "Displays a tree of the file system"},
        {"processes", cmd_processes, "Shows info about active processes"},
        {"set", cmd_set, "Shows or sets env variables"}
    };
    // ============
    
    write("== Welcome to SubleqOS Shell ==\n"); // TODO this and cwd printing could be turned off with an env variable
    write("type 'help' for commands\n\n");
    while(1) {
        write(">");
        int args = malloc(0);
        int nextArg = malloc(0);
        char ch = getch();
        int inQuotes = 0;
        
        inline void pushArg(int* arg) {
            int newArgs = malloc(len(args)+1);
            memcopy(args, len(args), newArgs);
            newArgs[len(args)] = arg;
            free(args);
            args = newArgs;
        }
        
        while(ch != '\n') {
            if(ch == '"') {
                inQuotes = !inQuotes;
                ch = getch();
                continue;
            }
            if(ch == ' ' && !inQuotes) {
                pushArg(nextArg);
                nextArg = malloc(0);
                ch = getch();
                continue;
            }
            if(ch == '\\') {
                ch = getch();
                if(ch == 'n') ch = '\n';
                if(ch == '0') ch = '\0';
                if(ch == 't') ch = '\t';
                else ch = ch;
            }
            int* newNextArg = malloc(len(nextArg)+1);
            memcopy(nextArg, len(nextArg), newNextArg);
            newNextArg[len(nextArg)] = ch;
            free(nextArg);
            nextArg = newNextArg;
            ch = getch();
        }
        pushArg(nextArg);
        
        // Process command
        if(len(args) == 1 && len(args[0]) == 0) {
            free(args[0]);
            free(args);
            process_wait(proc);
        } else {
            int cmdI = -1;
            for(int i=0; i<len(cmds); i++) {
                if(streq(args[0], cmds[i][0])) {
                    cmdI = i;
                }
            }
            if(cmdI >= 0) {
                cmds[cmdI][1](args);
            } else {
                write("Unknown command: '"); write(args[0]); write("'");
                for(int i=0; i<len(args); i++)
                    free(args[i]);
                free(args);
            }
            write("\n");
            process_wait(proc);
        }
    }
    // cleanup
    CLEANUP:
    free(lastChunk);
    proc[6] = exitCode;
    process_exit(proc);
}



// === BOOT ===
static void bluescreen_setup() {
    static int bluescreen_func(char* str) {
        true_print("\n= BLUESCREEN FAILURE =");
        true_write("ERROR: "); true_print(str);
        if(BLUESCREEN_DATA_STR) { true_write("ERRDATA: "); true_print(BLUESCREEN_DATA_STR); }
        true_print("SYSTEM SHUTDOWN");
        asm { @0 @0 -1 }
    }
    BLUESCREEN = bluescreen_func;
}


int os_boot_mode = 0; // 0=shell, 1=gui
static int OSBOOT() {
    
    if(os_boot_mode != 0) BLUESCREEN("GUI Not Implemented");
    
    // Boot Sequence
    os_log("Booting into mode "); os_log(itoa_no_malloc(os_boot_mode)); os_log("\n");
    fs_init();
    env_init_global();
    
    if(os_boot_mode == 0) { // Shell mode
        int* initialProc = new_process(clone("rootproc"));
        initialProc[1] = initialProcContinue;
        int* shellProc = NULL;
        int* shellDynFunc = NULL;
        bool shellProcExited = 0;
        
        int* shellStdin;
        int* shellStdout;
        int* shellEnv = NULL;
        static void requestLine(int w) {
            char ch = 0;
            while(ch != '\n') {
                ch = true_io_getch;
                int* data = malloc(1);
                data[0] = ch;
                stream_send(shellStdin, data);
            }
        }
        shellStdin = new_stream(requestLine);
        shellStdout = new_stream(NULL);
        shellEnv = new_envtable(); // is freed by proc loop
        shellEnv[0] = global_envtable;
        
        static void onBeforeShellExit(int* proc) {
            // write the last stuff in the output stream since we don't want to miss data before exiting
            while(1) {
                int* data = stream_recv(shellStdout);
                if(!data) break;
                true_write(data);
                free(data);
            }
            
            stream_finish(shellStdin);
            free_stream(shellStdin);
            stream_finish(shellStdout);
            free_stream(shellStdout);
            
            free(shellDynFunc);
            shellProcExited = 1;
            
            os_log("In initial process: Shell process exited, exiting soon\n");
        }
        
        jmp skip;
        initialProcContinue: // TODO restart shell if other processes than initialProc are active after shell exits
        while(1) { // print exit code and stderr of shell
            if(!shellProc) {
                os_log("In initial process: starting shell\n");
                os_log("\n");
                shellProc = new_process(clone("sh initial"));
                shellProc[3] = shellStdin;
                shellProc[4] = shellStdout;
                shellProc[7] = onBeforeShellExit;
                shellProc[8] = shellEnv;
                shellDynFunc = load(dynf_ptr(spawnShell));
                shellDynFunc(shellProc);
                add_process(shellProc);
            }
            process_wait(initialProc);
            if(shellProcExited) {
                // Exit
                process_exit(initialProc);
            }
            // Handle shellStdout
            // All the data should be printed since shell could do input after
            while(1) {
                int* data = stream_recv(shellStdout);
                if(!data) break;
                true_write(data);
                free(data);
            }
        }
        skip:
        add_process(initialProc);
    }
    PROCESS_LOOP();
    
    asm { @0 @0 -1 }
}
static int OSMAIN() {
    true_write("Welcome to "); true_write(OS_NAME); true_write(" "); true_print(OS_VERSION);
    true_write("\n");
    
    
    bluescreen_setup();
    static void os_log_func(char* str) {
        true_write(str);
    }
    os_log = os_log_func;
    
    
    // we avoid using malloc here
    true_print("= OS SAFE CONFIG SHELL =");
    true_print("Type 'boot_sh' or 'boot_gui' to boot.");
    true_print("Type 'help' for a list of commands.");
    
    char ch;
    while(1) {
        cmdagain:
        
        static void err(char* str) {
            true_print(str);
            while(ch != '\n') ch = true_io_getch;
            jmp cmdagain;
        }
        
        true_write(">");
        ch = true_io_getch;
        if(ch == '\n') continue;
        int cmdname = "\0\0\0\0\0\0\0\0\0\0";
        int i = 0;
        while(ch != ' ' && ch != '\n') {
            if(i >= len(cmdname)) err("Command too long!");
            cmdname[i] = ch;
            i++;
            ch = true_io_getch;
        }
        if(ch == ' ') ch = true_io_getch;
        
        static void isCmd(char* str) {
            if(len(str) != i) return 0;
            for(int j=0; j<i; j++)
                if(str[j] != cmdname[j]) return 0;
            return 1;
        }
        
        if(isCmd("help")) {
            true_print("- List of commands -");
            true_print("help             shows list of commands");
            true_print("boot_sh          boots into shell");
            true_print("boot_gui         boots into GUI");
            true_print("echo             prints to the screen");
            true_print("exit             shutdown");
            true_print("restart          effectively restart the system");
            true_print("trig_bsod        trigger a blue screen");
            true_print("sysinfo          displays some info about the system and environment");
            true_print("fs_info <path>   displays info about a file object");
            true_print("fs_init          initializes the file system (otherwise done automatically on boot)");
        } else if(isCmd("boot_sh")) {
            os_boot_mode = 0;
            OSBOOT();
        } else if(isCmd("boot_gui")) {
            os_boot_mode = 1;
            OSBOOT();
        } else if(isCmd("echo")) {
            while(ch != '\n') {
                true_io_putch ch;
                ch = true_io_getch;
            }
        } else if(isCmd("exit")) {
            asm { @0 @0 -1 }
        } else if(isCmd("restart")) {
            asm { @0 @0 0 }
        } else if(isCmd("sysinfo")) {
            true_write("Initial size: "); true_print(itoa_no_malloc(program_end_addr-program_start_addr));
            true_write("OS Name: "); true_print(OS_NAME);
            true_write("OS Version: "); true_print(OS_VERSION);
        } else if(isCmd("trig_bsod")) {
            BLUESCREEN("Bluescreen triggered from OS Safe Config Shell");
        } else if(isCmd("fs_info")) {
            int* path = malloc(0);
            while(ch != '\n') {
                int* newPath = malloc(len(path)+1);
                memcopy(path, len(path), newPath);
                newPath[len(path)] = ch;
                free(path);
                path = newPath;
                ch = true_io_getch;
            }
            true_write("Path: '"); true_write(path); true_write("'\n");
            int* res = fs_get(path, NULL);
            
            if(!res) {
                true_write("FS Error: "); true_write(fs_get_err); true_write("\n");
            } else {
                true_write("- file object info -\n");
                if(res[1] == 'f') true_write("Type: File ('f')\n");
                else if(res[1] == 'D') true_write("Type: Folder ('D')\n");
                else {
                    true_write("Type: Unknown\n");
                    jmp cmdagain;
                }
                true_write("Name: "); true_write(res[2]); true_write("\n");
                if(res[1] == 'f') {
                    true_write("File size: "); true_write(itoa_no_malloc(len(res[3]))); true_write("\n");
                }
            }
            
            free(path);
        } else if(isCmd("fs_init")) {
            if(!*fs_root) {
                fs_init();
            } else {
                true_write("Error: File system already initialized\n");
            }
        } else err("Unknown command");
        while(ch != '\n') ch = true_io_getch;
        true_write("\n");
    }
}
OSMAIN();