// Generated

{
	const astNodes = new WeakSet();
	const astHandler = {
		get: (target, key) => {
			if(Object.hasOwn(target.ast_memoized_merged_nodes, key)) return target.ast_memoized_merged_nodes[key];
			if(target.ast_node_names.has(key)) {
				let nodes = target.astnodes.filter(node => node.astname === key);
				const merged = new ASTNode(key, nodes.map(node => node.astvalues).flat(), nodes.map(node => node.text).join(""), nodes[0].start, nodes.at(-1).end);
				target.ast_memoized_merged_nodes[key] = merged;
				return merged;
			}
			if(Reflect.has(target, key)) return Reflect.get(target, key);
			return undefined; // Signals that no such property or node exists
		},
	};
	function astToString() {
		let ast = this;
		let stringsJoined = ast.reduce((arr, val) => typeof val === "string" && arr.length > 0 && typeof arr.at(-1) === "string" ? [...arr.slice(0, arr.length-1), arr.at(-1)+val] : [...arr, val], []);
		return ast.astname + " {\n" + stringsJoined.map(val => astNodes.has(val) ? val.toString().split("\n") : [val]).flat().map(line => "  " + line).join("\n") + "\n}";
	}
	function ASTNode(name, results, text, start, end) {
		let o = results.slice();
		o.astname = name;
		o.astvalues = results;
		o.astnodes = results.filter(val => astNodes.has(val));
		o.ast_memoized_merged_nodes = {};
		o.ast_node_names = new Set(o.astnodes.map(node => node.astname));
		o.text = text;
		o.emitted = results.map(val => astNodes.has(val) ? val.emitted : val).join(""); // .emitted is a string of all emitted text
		o.start = start;
		o.end = end;
		o.toString = astToString;
		let proxy = new Proxy(o, astHandler);
		astNodes.add(proxy);
		return proxy;
	}
	Object.defineProperty(ASTNode, Symbol.hasInstance, {
		value: (value) => {
			return astNodes.has(value);
		},
	});
	globalThis.ASTNode = ASTNode;
}


globalThis.parse = parse;
function parse(code, { start: startDefName = "main", filename: filename = null, custom_defs = {} } = {}) {
	
	const defs = {};
	const visualNames = {};
	const memoized = {};

	// Used for error generation
	let last = {
		entered: { name: null, start: null },
		exited: { name: null, end: null },
	};
	let furthest = {
		entered: { name: null, start: null },
		exited: { name: null, end: null },
		pos: 0, // At the end of parsing, will be the furthest successfully parsed excluding exprs inside non-consuming exprs
	};
	function getFurthestBackup() { // For non-consuming exprs to be able to restore furthest
		return structuredClone(furthest);
	}

	function match(results, start, end) {
		if(end >= furthest.pos) {
			furthest.pos = end;
			furthest.entered = last.entered;
			furthest.exited = last.exited;
		}
		return { matched: true, results, start, end };
	}
	function fail() {
		return { matched: false };
	}
	
	const exprs = {};
	exprs.str = (s) => (start) => {
		return code.slice(start, start+s.length) === s ? match([], start, start+s.length) : fail();
	};
	exprs.eof = () => (start) => {
		return start === code.length ? match([], start, start) : fail();
	};
	exprs.def = (name) => (start) => {
		let prevEntered = last.entered;
		if(Object.hasOwn(visualNames, name)) last.entered = { name, start };
		
		if(!Object.hasOwn(memoized, name)) memoized[name] = new Map();
		if(!memoized[name].has(start)) {
			if(Object.hasOwn(defs, name)) memoized[name].set(start, { result: defs[name](start), furthest: getFurthestBackup() });
			else if(Object.hasOwn(custom_defs, name)) memoized[name].set(start, { result: custom_defs[name]({ defs, exprs, code, match, fail }, start), furthest: getFurthestBackup() });
			else throw new Error("Unknown definition: " + name);
		}
		let { result: res, furthest: furthestBackup } = memoized[name].get(start);

		if(furthestBackup.pos >= furthest.pos) furthest = furthestBackup;
		
		if(Object.hasOwn(visualNames, name)) last.entered = prevEntered;
		if(!res.matched) return fail();
		if(Object.hasOwn(visualNames, name)) last.exited = { name, end: res.end };
		return res;
	};
	exprs.join = (...funcs) => (start) => {
		let results = [];
		let curr = start;
		for(let func of funcs) {
			let res = func(curr);
			if(!res.matched) return fail();
			results = [...results, ...res.results];
			curr = res.end;
		}
		return match(results, start, curr);
	};
	exprs.choice = (...funcs) => (start) => {
		return funcs.reduce((res, func) => res.matched ? res : func(start), fail());
	};
	exprs.repeat = (func) => (start) => {
		let results = [];
		let curr = start;
		while(true) {
			let res = func(curr);
			if(!res.matched) return match(results, start, curr);
			results = [...results, ...res.results];
			curr = res.end;
		}
	};
	exprs.repeat_plus = (func) => (start) => {
		let res = func(start);
		if(!res.matched) return fail();
		let results = res.results;
		let curr = res.end;
		while(true) {
			let res = func(curr);
			if(!res.matched) return match(results, start, curr);
			results = [...results, ...res.results];
			curr = res.end;
		}
	};
	exprs.optional = (func) => (start) => {
		let res = func(start);
		return res.matched ? res : match([], start, start);
	};
	exprs.not = (func) => (start) => {
		const furthestBackup = getFurthestBackup();
		let res = func(start);
		furthest = furthestBackup;
		return res.matched ? fail() : match([], start, start);
	};
	exprs.and = (func) => (start) => {
		const furthestBackup = getFurthestBackup();
		let res = func(start);
		furthest = furthestBackup;
		return res.matched ? match([], start, start) : fail();
	};
	exprs.noemit = (func) => (start) => {
		let res = func(start);
		return res.matched ? match([], start, res.end) : fail();
	};
	exprs.noconsume = (func) => (start) => {
		const furthestBackup = getFurthestBackup();
		let res = func(start);
		furthest = furthestBackup;
		return res.matched ? match(res.results, start, start) : fail();
	};
	exprs.char_range = (start_char, end_char) => {
		if(start_char.charCodeAt(0) > end_char.charCodeAt(0)) throw new Error("Char range must not be reversed (ex: Z-A)");
		return (start) => {
			return start < code.length && code[start].charCodeAt(0) >= start_char.charCodeAt(0) && code[start].charCodeAt(0) <= end_char.charCodeAt(0) ? match([], start, start+1) : fail();
		};
	};
	exprs.emit_code = (str) => (start) => {
		return match([str], start, start);
	};
	exprs.emit_consumed = (func) => (start) => {
		let res = func(start);
		return res.matched ? match([code.slice(start, res.end)], start, res.end) : fail();
	};
	exprs.named = (name, func) => (start) => {
		let res = func(start);
		return res.matched ? match([new ASTNode(name, res.results, code.slice(start, res.end), start, res.end)], start, res.end) : fail();
	};


	function define(name, visualName, func) {
		if(Object.hasOwn(defs, name)) throw new Error("Duplicate definition: " + name);
		defs[name] = func;
		if(visualName !== null) visualNames[name] = visualName;
	}

	// Definitions
	define("_", null, exprs.repeat(exprs.choice(exprs.str(" "), exprs.str("\t"), exprs.str("\n"), exprs.def("comment"))));
	define("comment", "comment", exprs.choice(exprs.join(exprs.str("//"), exprs.repeat(exprs.join(exprs.not(exprs.str("\n")), exprs.char_range("\x00", "\xFF"))), exprs.optional(exprs.str("\n"))), exprs.def("multiline_comment")));
	define("multiline_comment", null, exprs.join(exprs.str("/*"), exprs.repeat(exprs.choice(exprs.def("multiline_comment"), exprs.join(exprs.not(exprs.str("*/")), exprs.char_range("\x00", "\xFF")))), exprs.str("*/")));
	define("EMIT_ANY", null, exprs.choice(exprs.join(exprs.not(exprs.str("\"")), exprs.not(exprs.str("\'")), exprs.not(exprs.str("\\")), exprs.emit_consumed(exprs.char_range("\x20", "\x7e"))), exprs.join(exprs.str("\n"), exprs.emit_code("\\n")), exprs.join(exprs.emit_code("\\"), exprs.emit_consumed(exprs.char_range("\x00", "\xFF")))));
	define("HEX", null, exprs.choice(exprs.char_range("0", "9"), exprs.char_range("a", "f"), exprs.char_range("A", "F")));
	define("identifier", "identifier", exprs.join(exprs.choice(exprs.char_range("a", "z"), exprs.char_range("A", "Z"), exprs.str("_")), exprs.repeat(exprs.choice(exprs.char_range("a", "z"), exprs.char_range("A", "Z"), exprs.char_range("0", "9"), exprs.str("_")))));
	define("idend", null, exprs.not(exprs.choice(exprs.char_range("A", "Z"), exprs.char_range("a", "z"), exprs.char_range("0", "9"), exprs.str("_"))));
	define("string", "string", exprs.join(exprs.emit_code("\""), exprs.join(exprs.str("\""), exprs.repeat(exprs.join(exprs.not(exprs.str("\"")), exprs.not(exprs.str("\n")), exprs.def("char"))), exprs.str("\"")), exprs.emit_code("\"")));
	define("char", null, exprs.choice(exprs.def("escape"), exprs.join(exprs.not(exprs.str("\\")), exprs.def("EMIT_ANY"))));
	define("escape", null, exprs.choice(exprs.join(exprs.str("\\"), exprs.def("escape_combos")), exprs.join(exprs.str("\\"), exprs.choice(exprs.str("x"), exprs.str("X")), exprs.emit_code("\\x"), exprs.emit_consumed(exprs.def("HEX")), exprs.emit_consumed(exprs.def("HEX")))));
	define("escape_combos", null, exprs.choice(exprs.join(exprs.str("n"), exprs.emit_code("\\n")), exprs.join(exprs.str("t"), exprs.emit_code("\\t")), exprs.join(exprs.str("r"), exprs.emit_code("\\r")), exprs.join(exprs.str("\""), exprs.emit_code("\\\"")), exprs.join(exprs.str("\'"), exprs.emit_code("\\\'")), exprs.join(exprs.str("\\"), exprs.emit_code("\\\\")), exprs.join(exprs.str("0"), exprs.emit_code("\\0"))));
	define("integer", "integer", exprs.join(exprs.emit_code("("), exprs.optional(exprs.emit_consumed(exprs.str("-"))), exprs.emit_consumed(exprs.choice(exprs.join(exprs.char_range("1", "9"), exprs.repeat(exprs.char_range("0", "9"))), exprs.str("0"))), exprs.emit_code("n)")));
	define("primitive_type", null, exprs.join(exprs.choice(exprs.str("int"), exprs.str("char"), exprs.str("string"), exprs.str("void"), exprs.str("bool")), exprs.def("idend")));
	define("type", null, exprs.join(exprs.choice(exprs.join(exprs.str("const"), exprs.def("idend"), exprs.optional(exprs.join(exprs.def("_"), exprs.def("primitive_type")))), exprs.join(exprs.str("mallocated"), exprs.def("idend"), exprs.optional(exprs.join(exprs.def("_"), exprs.def("primitive_type")))), exprs.def("primitive_type")), exprs.repeat(exprs.join(exprs.def("_"), exprs.str("*")))));
	define("main", "program", exprs.join(exprs.def("PREPEND_CODE"), exprs.def("_"), exprs.def("scope_block"), exprs.def("_"), exprs.def("APPEND_CODE")));
	define("scope_block", null, exprs.join(exprs.noconsume(exprs.repeat(exprs.join(exprs.def("_"), exprs.choice(exprs.def("lbl_stmt_predecl"), exprs.noemit(exprs.def("semicolon_statement")))))), exprs.repeat(exprs.join(exprs.def("_"), exprs.def("semicolon_statement")))));
	define("lbl_stmt_predecl", null, exprs.named("Label", exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.str(":"), exprs.emit_code("\"; let lbl = mkLabel(\"varlbl_\"+name); let variable = scopes.at(-1).makeVar(name, b.addData(mkRef(lbl))); }"))));
	define("lbl_stmt_at", null, exprs.named("Label", exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.str(":"), exprs.emit_code("\"; let lblRef = scopes.at(-1).variables.get(name).data; assert(lblRef && lblRef.value); b.add(lblRef.value); }"))));
	define("semicolon_statement", "statement", exprs.choice(exprs.join(exprs.str("while"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let oldScopes = scopes; { let scopes = [...oldScopes, new Scope()]; let tmp = b.tmp(); let retval = tmp.data; let lblCheck = b.add(mkLabel(\"whilecheck\")); "), exprs.def("expr"), exprs.def("_"), exprs.str(")"), exprs.def("_"), exprs.emit_code(" let lblEnd = mkLabel(\"whileend\"); scopes.at(-1).loopBreakLbl = lblEnd; scopes.at(-1).loopContinueLbl = lblCheck; b.add(mkLitRef(0n), mkRef(retval), mkRef(lblEnd)); "), exprs.def("semicolon_statement"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(lblCheck), lblEnd); tmp.release(); }}")), exprs.join(exprs.str("for"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let oldScopes = scopes; { let scopes = [...oldScopes, new Scope()]; "), exprs.optional(exprs.join(exprs.def("statement"), exprs.def("_"))), exprs.str(";"), exprs.def("_"), exprs.emit_code(" let tmp = b.tmp(); let retval = tmp.data; let lbl2ndtime = mkLabel(\"for2ndtime\"); let lblCheck = b.add(mkLabel(\"forcheck\")); let lblBody = mkLabel(\"forbody\"); let lblEnd = mkLabel(\"forend\"); scopes.at(-1).loopBreakLbl = lblEnd; scopes.at(-1).loopContinueLbl = lbl2ndtime; "), exprs.choice(exprs.join(exprs.def("expr"), exprs.def("_")), exprs.emit_code("b.setZ(retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt());")), exprs.str(";"), exprs.def("_"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRef(lblEnd)); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(lblBody)); b.add(lbl2ndtime); "), exprs.optional(exprs.join(exprs.def("statement"), exprs.def("_"))), exprs.str(")"), exprs.def("_"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(lblCheck)); b.add(lblBody); "), exprs.def("semicolon_statement"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(lbl2ndtime), lblEnd); tmp.release(); } }")), exprs.named("BlockStmt", exprs.join(exprs.emit_code("{ let oldScopes = scopes; { let scopes = [...oldScopes, new Scope()]; "), exprs.str("{"), exprs.def("_"), exprs.def("scope_block"), exprs.def("_"), exprs.str("}"), exprs.emit_code(" } }"))), exprs.def("lbl_stmt_at"), exprs.join(exprs.str("jmp"), exprs.def("idend"), exprs.def("_"), exprs.emit_code("{ let retval = mkLabel(\"jmp\"); "), exprs.def("expr"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), retval, mkUninit()); }"), exprs.def("_"), exprs.str(";")), exprs.join(exprs.str("break"), exprs.def("idend"), exprs.def("_"), exprs.emit_code("{ let scope = scopes.slice().reverse().find(scope => scope.loopBreakLbl); if(!scope) throw new Error(\"Break can only be in loop\"); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(scope.loopBreakLbl)); }"), exprs.def("_"), exprs.str(";")), exprs.join(exprs.str("continue"), exprs.def("idend"), exprs.def("_"), exprs.emit_code("{ let scope = scopes.slice().reverse().find(scope => scope.loopContinueLbl); if(!scope) throw new Error(\"Continue can only be in loop\"); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(scope.loopContinueLbl)); }"), exprs.def("_"), exprs.str(";")), exprs.join(exprs.str("return"), exprs.def("idend"), exprs.def("_"), exprs.emit_code("{ let scope = scopes.slice().reverse().find(scope => scope.funcRetvalData); if(!scope) throw new Error(\"Return can only be in function\"); let retval = scope.funcRetvalData; /*this should be safe to do*/ "), exprs.def("expr"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(scope.funcRetLbl)); }"), exprs.def("_"), exprs.str(";")), exprs.def("if_stmt"), exprs.def("function_stmt"), exprs.join(exprs.def("statement"), exprs.def("_"), exprs.str(";")), exprs.def("asm_stmt"), exprs.str(";")));
	define("statement", "statement", exprs.choice(exprs.def("declaration"), exprs.named("Assign", exprs.join(exprs.emit_code("{ let addrTmp = b.tmp(); let retval = addrTmp.data; "), exprs.def("lvalue"), exprs.def("_"), exprs.str("="), exprs.def("_"), exprs.emit_code(" let exprTmp = b.tmp(); retval = exprTmp.data; "), exprs.def("expr"), exprs.emit_code(" let negAddrTmp = b.tmp(); b.setZ(negAddrTmp.data); b.subTo(addrTmp.data, negAddrTmp.data); let [lbl1, lbl2, lbl3] = [mkLabel(\"assign1\"), mkLabel(\"assign2\"), mkLabel(\"assign3\")]; b.setZ(lbl1); b.setZ(lbl2); b.setZ(lbl3); b.subTo(negAddrTmp.data, lbl1); b.subTo(negAddrTmp.data, lbl2); b.subTo(negAddrTmp.data, lbl3); b.setZ(addrTmp.data); b.subTo(exprTmp.data, addrTmp.data); b.add(lbl1, mkUninit(), lbl2, mkUninit(), mkNxt(), mkRef(addrTmp.data), lbl3, mkUninit(), mkNxt()); addrTmp.release(); exprTmp.release(); negAddrTmp.release(); }"))), exprs.named("PlusOrMinusEquals", exprs.join(exprs.emit_code("{ let addrLbl = mkLabel(\"pluseqaddr\"); let retval = addrLbl; "), exprs.def("lvalue"), exprs.def("_"), exprs.emit_code(" let op = \""), exprs.emit_consumed(exprs.choice(exprs.str("+="), exprs.str("-="))), exprs.def("_"), exprs.emit_code("\"; let exprTmp = b.tmp(); retval = exprTmp.data; "), exprs.def("expr"), exprs.emit_code(" if(op === \"-=\") {b.add(mkRef(exprTmp.data), addrLbl, mkUninit(), mkNxt());} else {b.setZ(b.jmpTmp); b.subTo(exprTmp.data, b.jmpTmp); b.add(mkRef(b.jmpTmp), addrLbl, mkUninit(), mkNxt());} exprTmp.release(); }"))), exprs.named("PlusPlusOrMinusMinus", exprs.join(exprs.emit_code("{ let addrLbl = mkLabel(\"plusplusaddr\"); let retval = addrLbl; "), exprs.def("lvalue"), exprs.def("_"), exprs.emit_code(" let op = \""), exprs.emit_consumed(exprs.choice(exprs.str("++"), exprs.str("--"))), exprs.emit_code("\"; b.add(mkLitRef(op === \"++\" ? -1n : 1n), addrLbl, mkUninit(), mkNxt()); }"))), exprs.join(exprs.str("true_io_putch"), exprs.def("idend"), exprs.def("_"), exprs.emit_code("{ let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("expr"), exprs.emit_code(" b.add(mkRef(retval), mkLiteral(-1n), mkNxt()); tmp.release(); }")), exprs.named("Free", exprs.join(exprs.str("true_free"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let ptr = b.addData(mkUninit()); { let retval = ptr; "), exprs.def("expr"), exprs.emit_code(" } free(b, ptr); }"), exprs.def("_"), exprs.str(")"))), exprs.named("ExprStmt", exprs.join(exprs.emit_code("{ let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("expr"), exprs.emit_code(" tmp.release(); }")))));
	define("if_stmt", null, exprs.join(exprs.emit_code("{ let afterLbl = mkLabel(\"if.after\");"), exprs.str("if"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let skipLbl = mkLabel(\"if.skip\"); let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("expr"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRef(skipLbl)); tmp.release(); "), exprs.def("_"), exprs.str(")"), exprs.def("_"), exprs.def("semicolon_statement"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl), skipLbl); }"), exprs.repeat(exprs.join(exprs.def("_"), exprs.str("else"), exprs.def("idend"), exprs.def("_"), exprs.str("if"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let skipLbl = mkLabel(\"if.ifelseskip\"); let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("expr"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRef(skipLbl)); tmp.release(); "), exprs.def("_"), exprs.str(")"), exprs.def("_"), exprs.def("semicolon_statement"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl), skipLbl); }"))), exprs.optional(exprs.join(exprs.def("_"), exprs.str("else"), exprs.def("idend"), exprs.def("_"), exprs.def("semicolon_statement"))), exprs.emit_code("b.add(afterLbl); }")));
	define("declaration", null, exprs.choice(exprs.join(exprs.def("type"), exprs.def("_"), exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let variable = scopes.at(-1).makeVar(name, b.addData(mkUninit(\"var_\"+name))); let retval = variable.data; "), exprs.def("_"), exprs.str("="), exprs.def("_"), exprs.def("expr"), exprs.emit_code(" }")), exprs.join(exprs.def("type"), exprs.def("_"), exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let variable = scopes.at(-1).makeVar(name, b.addData(mkUninit(\"var_\"+name))); }"))));
	define("function_stmt", null, exprs.choice(exprs.def("static_function"), exprs.def("inline_function"), exprs.def("dynamic_function")));
	define("static_function", null, exprs.join(exprs.emit_code("{ let name = \""), exprs.optional(exprs.join(exprs.str("static"), exprs.def("idend"), exprs.def("_"))), exprs.def("type"), exprs.def("_"), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.emit_code("\"; let lbl = mkLabel(\"func\"); let entryLbl = mkLabel(\"funcentry\"); let retAddrData = mkUninit(); let variable = scopes.at(-1).makeVar(name, b.addData(mkRef(lbl)));"), exprs.emit_code("let argNames = ["), exprs.str("("), exprs.optional(exprs.join(exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_code("\""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\""), exprs.repeat(exprs.join(exprs.def("_"), exprs.str(","), exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_code(", \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\""))))), exprs.def("_"), exprs.str(")"), exprs.emit_code("]; let argData = argNames.map(name => mkUninit());"), exprs.emit_code("let oldScopes = scopes; { let scopes = [...oldScopes, new Scope()]; let skipLbl = mkLabel(\"funcskip\"); argNames.forEach((name, i) => scopes.at(-1).makeVar(name, argData[i])); let funcRetvalData = mkUninit(); let funcRetLbl = mkLabel(\"funcscoperetlbl\"); scopes.at(-1).funcRetvalData = funcRetvalData; scopes.at(-1).funcRetLbl = funcRetLbl;"), exprs.emit_code("b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(skipLbl)); b.pushTemps(); b.add(lbl, mkRef(entryLbl), retAddrData, funcRetvalData, ...argData);"), exprs.emit_code("b.add(entryLbl);"), exprs.def("_"), exprs.def("semicolon_statement"), exprs.emit_code("b.add(funcRetLbl); let retJmpLbl = mkLabel(\"func.retjmp\"); b.copyTo(retAddrData, retJmpLbl); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), retJmpLbl, mkUninit()); b.popTemps(); "), exprs.emit_code("b.add(skipLbl); }}")));
	define("inline_function", null, exprs.join(exprs.emit_code("{ let name = \""), exprs.str("inline"), exprs.def("idend"), exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.emit_code("\"; let func = scopes.at(-1).makeFunc(name, new InlineFunc());"), exprs.emit_code("let argNames = ["), exprs.str("("), exprs.optional(exprs.join(exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_code("\""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\""), exprs.repeat(exprs.join(exprs.def("_"), exprs.str(","), exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_code(", \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\""))))), exprs.def("_"), exprs.str(")"), exprs.emit_code("]; func.argNames = argNames;"), exprs.emit_code("func.generate = function(b, scopes, argData, retval) { let oldScopes = scopes; { let scopes = [...oldScopes, new Scope()]; argNames.forEach((name, i) => scopes.at(-1).makeVar(name, argData[i])); let funcRetLbl = mkLabel(\"inlinefuncscoperetlbl\"); scopes.at(-1).funcRetvalData = retval; scopes.at(-1).funcRetLbl = funcRetLbl;"), exprs.def("_"), exprs.def("semicolon_statement"), exprs.emit_code("b.add(funcRetLbl); }};}")));
	define("dynamic_function", null, exprs.join(exprs.emit_code("{ let name = \""), exprs.str("dynamic"), exprs.def("idend"), exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.emit_code("\"; let lbl = mkLabel(\"func\"); let entryLbl = mkLabel(\"funcentry\"); let retAddrData = mkUninit(); let func = scopes.at(-1).makeFunc(name, new DynamicFunc()); func.lbl = lbl;"), exprs.emit_code("let argNames = ["), exprs.str("("), exprs.optional(exprs.join(exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_code("\""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\""), exprs.repeat(exprs.join(exprs.def("_"), exprs.str(","), exprs.def("_"), exprs.def("type"), exprs.def("_"), exprs.emit_code(", \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\""))))), exprs.def("_"), exprs.str(")"), exprs.emit_code("]; let argData = argNames.map(name => mkUninit());"), exprs.emit_code("let oldScopes = scopes; let origB = b; { let scopes = [...oldScopes, new Scope()]; let skipLbl = mkLabel(\"funcskip\"); argNames.forEach((name, i) => scopes.at(-1).makeVar(name, argData[i])); let funcRetvalData = mkUninit(); let funcRetLbl = mkLabel(\"funcscoperetlbl\"); scopes.at(-1).funcRetvalData = funcRetvalData; scopes.at(-1).funcRetLbl = funcRetLbl;"), exprs.emit_code("b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(skipLbl)); let endLbl = mkLabel(\"dynfunc.end\"), lengthLbl = mkLabel(\"dynfunc.len\"); { origB.add(lengthLbl, mkUninit(), lbl); let b = origB.add(new Block()); b.true_header.push(mkRef(entryLbl), retAddrData, funcRetvalData, ...argData, entryLbl);"), exprs.def("_"), exprs.def("semicolon_statement"), exprs.emit_code("b.add(funcRetLbl); let retJmpLbl = mkLabel(\"func.retjmp\"); b.copyTo(retAddrData, retJmpLbl); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), retJmpLbl, mkUninit()); } "), exprs.emit_code("b.add(endLbl, skipLbl); b.copyTo(b.addData(mkRef(endLbl)), lengthLbl); b.subTo(b.addData(mkRef(lbl)), lengthLbl); }}")));
	define("asm_stmt", "asm statement", exprs.join(exprs.str("asm"), exprs.def("idend"), exprs.def("_"), exprs.str("{"), exprs.emit_code("{ let asmLabels = new Map(); "), exprs.noconsume(exprs.repeat(exprs.join(exprs.def("_"), exprs.choice(exprs.def("asm_label_pre"), exprs.noemit(exprs.def("asm_stmt_instr")))))), exprs.repeat(exprs.join(exprs.def("_"), exprs.def("asm_stmt_instr"))), exprs.emit_code(" }"), exprs.def("_"), exprs.str("}")));
	define("asm_label_pre", null, exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.str(":"), exprs.emit_code("\"; if(asmLabels.has(name)) throw new Error(\"Duplicate asm label in same scope: \"+name); asmLabels.set(name, mkLabel(\"asmlbl_\"+name)); }")));
	define("asm_stmt_instr", null, exprs.choice(exprs.named("Int", exprs.join(exprs.emit_code("b.add(mkLiteral("), exprs.def("integer"), exprs.emit_code("));"))), exprs.named("IntRef", exprs.join(exprs.str("@"), exprs.emit_code("b.add(mkLitRef("), exprs.def("integer"), exprs.emit_code("));"))), exprs.named("Offset", exprs.join(exprs.emit_code("{ let offset = 0n; "), exprs.str("?"), exprs.optional(exprs.choice(exprs.join(exprs.str("+"), exprs.emit_code("offset += "), exprs.def("integer"), exprs.emit_code(";")), exprs.join(exprs.str("-"), exprs.emit_code("offset -= "), exprs.def("integer"), exprs.emit_code(";")))), exprs.emit_code(" b.add(mkRelative(offset)); }"))), exprs.named("Label", exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.def("_"), exprs.str(":"), exprs.emit_code("\"; assert(asmLabels.has(name)); b.add(asmLabels.get(name)); }"))), exprs.named("Variable", exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.variables.has(name)); if(!asmLabels.has(name) && !scope) throw new Error(\"Unknown asm label or variable: \"+name); if(asmLabels.has(name)) { b.add(mkRef(asmLabels.get(name))); } else { b.add(mkRef(scope.variables.get(name).data)); } }")))));
	define("expr", "expression", exprs.def("ternary_expr"));
	define("ternary_expr", null, exprs.choice(exprs.join(exprs.def("or_expr"), exprs.def("_"), exprs.str("?"), exprs.def("_"), exprs.emit_code(" { let noLbl = mkLabel(\"ternaryno\"); let afterLbl = mkLabel(\"ternaryafter\"); b.add(mkLitRef(0n), mkRef(retval), mkRef(noLbl)); "), exprs.def("or_expr"), exprs.def("_"), exprs.str(":"), exprs.def("_"), exprs.emit_code(" b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl), noLbl); "), exprs.def("ternary_expr"), exprs.emit_code(" b.add(afterLbl); }")), exprs.def("or_expr")));
	define("or_expr", null, exprs.choice(exprs.join(exprs.emit_code("{ let yesLbl = mkLabel(\"oryes\"); let afterLbl = mkLabel(\"orafter\"); "), exprs.def("and_expr"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRelative(4n), mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(yesLbl)); "), exprs.repeat_plus(exprs.join(exprs.def("_"), exprs.str("||"), exprs.def("_"), exprs.def("and_expr"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRelative(4n), mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(yesLbl)); "))), exprs.emit_code(" b.setZ(retval); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl)); b.add(yesLbl); b.setZ(retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt(), afterLbl); }")), exprs.def("and_expr")));
	define("and_expr", null, exprs.choice(exprs.join(exprs.emit_code("{ let noLbl = mkLabel(\"andno\"); let afterLbl = mkLabel(\"andafter\"); "), exprs.def("comp_expr"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRef(noLbl)); "), exprs.repeat_plus(exprs.join(exprs.def("_"), exprs.str("&&"), exprs.def("_"), exprs.def("comp_expr"), exprs.emit_code(" b.add(mkLitRef(0n), mkRef(retval), mkRef(noLbl)); "))), exprs.emit_code(" b.setZ(retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt()); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl)); b.add(noLbl); b.setZ(retval); b.add(afterLbl); }")), exprs.def("comp_expr")));
	define("comp_expr", null, exprs.choice(exprs.named("LessThan", exprs.join(exprs.emit_code("{ let tmp = b.tmp(); { let retval = tmp.data; "), exprs.def("sum_expr"), exprs.def("_"), exprs.str("<"), exprs.def("_"), exprs.emit_code("} "), exprs.def("sum_expr"), exprs.emit_code(" b.subTo(tmp.data, retval); tmp.release(); }"))), exprs.named("GreaterThan", exprs.join(exprs.emit_code("{ "), exprs.def("sum_expr"), exprs.def("_"), exprs.str(">"), exprs.def("_"), exprs.emit_code(" let tmp = b.tmp(); { let retval = tmp.data; "), exprs.def("sum_expr"), exprs.emit_code("} b.subTo(tmp.data, retval); tmp.release(); }"))), exprs.named("LessEqThan", exprs.join(exprs.emit_code("{ let tmp = b.tmp(); { let retval = tmp.data; "), exprs.def("sum_expr"), exprs.def("_"), exprs.str("<="), exprs.def("_"), exprs.emit_code("} "), exprs.def("sum_expr"), exprs.emit_code(" b.subTo(tmp.data, retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt()); tmp.release(); }"))), exprs.named("GreaterEqThan", exprs.join(exprs.emit_code("{ "), exprs.def("sum_expr"), exprs.def("_"), exprs.str(">="), exprs.def("_"), exprs.emit_code(" let tmp = b.tmp(); { let retval = tmp.data; "), exprs.def("sum_expr"), exprs.emit_code("} b.subTo(tmp.data, retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt()); tmp.release(); }"))), exprs.named("Equals", exprs.join(exprs.emit_code("{ "), exprs.def("sum_expr"), exprs.def("_"), exprs.str("=="), exprs.def("_"), exprs.emit_code(" let tmp = b.tmp(); { let retval = tmp.data; "), exprs.def("sum_expr"), exprs.emit_code("} b.subTo(tmp.data, retval); let lblNo = mkLabel(\"no\"), lblAfter = mkLabel(\"after\"); b.add(mkLitRef(-1n), mkRef(retval), mkRef(lblNo)); b.setZ(tmp.data); b.add(mkRef(retval), mkRef(tmp.data), mkNxt(), mkLitRef(-2n), mkRef(tmp.data), mkRef(lblNo)); b.setZ(retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt()); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(lblAfter), lblNo); b.setZ(retval); b.add(lblAfter); tmp.release(); }"))), exprs.named("NotEquals", exprs.join(exprs.emit_code("{ "), exprs.def("sum_expr"), exprs.def("_"), exprs.str("!="), exprs.def("_"), exprs.emit_code(" let tmp = b.tmp(); { let retval = tmp.data; "), exprs.def("sum_expr"), exprs.emit_code("} b.subTo(tmp.data, retval); let lblNo = mkLabel(\"no\"), lblAfter = mkLabel(\"after\"); /*lblNo is actually lblYes here*/ b.add(mkLitRef(-1n), mkRef(retval), mkRef(lblNo)); b.setZ(tmp.data); b.add(mkRef(retval), mkRef(tmp.data), mkNxt(), mkLitRef(-2n), mkRef(tmp.data), mkRef(lblNo)); b.setZ(retval); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(lblAfter), lblNo); b.setZ(retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt()); b.add(lblAfter); tmp.release(); }"))), exprs.def("sum_expr")));
	define("sum_expr", null, exprs.choice(exprs.named("Sum", exprs.join(exprs.emit_code("{ let origRetval = retval; "), exprs.def("prefix_expr"), exprs.emit_code(" "), exprs.repeat_plus(exprs.join(exprs.def("_"), exprs.emit_code("{ let op=\""), exprs.emit_consumed(exprs.choice(exprs.str("+"), exprs.str("-"))), exprs.def("_"), exprs.emit_code("\"; let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("prefix_expr"), exprs.emit_code(" if(op === \"+\") b.addTo(tmp.data, origRetval); else b.subTo(tmp.data, origRetval); tmp.release(); }"))), exprs.emit_code("}"))), exprs.def("prefix_expr")));
	define("prefix_expr", null, exprs.choice(exprs.named("Deref", exprs.join(exprs.str("*"), exprs.def("_"), exprs.emit_code("{ b.setZ(retval); let lbl = mkLabel(\"deref\"); let tmp = b.tmp(); b.setZ(tmp.data); { let retval = lbl; "), exprs.def("prefix_expr"), exprs.emit_code(" } b.add(lbl, mkUninit(), mkRef(tmp.data), mkNxt()); b.subTo(tmp.data, retval); tmp.release(); }"))), exprs.named("Length", exprs.join(exprs.str("len"), exprs.def("idend"), exprs.def("_"), exprs.emit_code("{ b.setZ(retval); let lbl = mkLabel(\"deref\"); let tmp = b.tmp(); b.setZ(tmp.data); { let retval = lbl; "), exprs.def("prefix_expr"), exprs.emit_code(" } b.add(mkLitRef(1n), mkRef(lbl), mkNxt()); b.add(lbl, mkUninit(), mkRef(tmp.data), mkNxt()); b.subTo(tmp.data, retval); tmp.release(); }"))), exprs.named("Negative", exprs.join(exprs.str("-"), exprs.def("_"), exprs.emit_code("{ let origRetval = retval; { let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("prefix_expr"), exprs.emit_code(" b.setZ(origRetval); b.subTo(tmp.data, origRetval); tmp.release(); }}"))), exprs.named("Not", exprs.join(exprs.str("!"), exprs.def("_"), exprs.emit_code("{ let origRetval = retval; { let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("prefix_expr"), exprs.emit_code(" b.setZ(origRetval); b.subTo(tmp.data, origRetval); b.add(mkLitRef(-1n), mkRef(origRetval), mkNxt()); tmp.release(); }}"))), exprs.named("AddrOf", exprs.join(exprs.str("&"), exprs.def("_"), exprs.def("lvalue"))), exprs.named("Malloc", exprs.join(exprs.str("true_malloc"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let origRetval = retval, size = b.addData(mkUninit()); { let retval = size; "), exprs.def("expr"), exprs.emit_code(" } malloc(b, origRetval, size); }"), exprs.def("_"), exprs.str(")"))), exprs.named("DynFuncPtr", exprs.join(exprs.str("dynf_ptr"), exprs.def("idend"), exprs.def("_"), exprs.str("("), exprs.def("_"), exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.nonStaticFuncs.has(name) && scope.nonStaticFuncs.get(name) instanceof DynamicFunc); if(!scope) throw new Error(\"dynf_ptr() recieved non-dynamic function or unknown variable\"); let lbl = scope.nonStaticFuncs.get(name).lbl; b.copyTo(b.addData(mkRef(lbl)), retval); }"), exprs.def("_"), exprs.str(")"))), exprs.def("after_prefix_expr")));
	define("after_prefix_expr", null, exprs.def("access_expr"));
	define("access_expr", null, exprs.choice(exprs.join(exprs.choice(exprs.def("possibly_nonstatic_funccall"), exprs.def("value")), exprs.repeat_plus(exprs.join(exprs.def("_"), exprs.def("access_expr_op")))), exprs.def("possibly_nonstatic_funccall"), exprs.def("value")));
	define("possibly_nonstatic_funccall", null, exprs.named("PossiblyNonStaticFuncCall", exprs.join(exprs.emit_code("{ let name=\""), exprs.noconsume(exprs.emit_consumed(exprs.def("identifier"))), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.nonStaticFuncs.has(name)); if(scope) { let func = scope.nonStaticFuncs.get(name); if(func instanceof InlineFunc) { "), exprs.noconsume(exprs.def("inline_call")), exprs.emit_code(" } else if(func instanceof DynamicFunc) { "), exprs.noconsume(exprs.def("dynamic_call")), exprs.emit_code(" } else throw new Error(\"Unknown/UnImplemented nonstatic function\"); } else { "), exprs.def("value"), exprs.def("_"), exprs.def("function_call_by_pointer"), exprs.emit_code(" }}"))));
	define("access_expr_op", null, exprs.choice(exprs.named("Index", exprs.join(exprs.emit_code("{ let lbl = mkLabel(\"deref\"); let tmp = b.tmp(); b.copyTo(retval, lbl); { let retval = tmp.data; "), exprs.def("_"), exprs.str("["), exprs.def("_"), exprs.def("expr"), exprs.def("_"), exprs.str("]"), exprs.emit_code(" b.addTo(tmp.data, lbl); } b.setZ(tmp.data); b.add(lbl, mkUninit(), mkRef(tmp.data), mkNxt()); b.setZ(retval); b.subTo(tmp.data, retval); tmp.release(); }"))), exprs.def("function_call_by_pointer")));
	define("function_call_by_pointer", null, exprs.join(exprs.emit_code("{ let currArgOff = 3n; let negTmp = b.tmp(); b.setZ(negTmp.data); b.subTo(retval, negTmp.data); let argTmps = [];"), exprs.str("("), exprs.optional(exprs.join(exprs.def("_"), exprs.def("function_call_by_pointer_arg"), exprs.repeat(exprs.join(exprs.def("_"), exprs.str(","), exprs.def("_"), exprs.def("function_call_by_pointer_arg"))))), exprs.def("_"), exprs.str(")"), exprs.emit_code("argTmps.forEach(tmp => { let addrLbl1 = mkLabel(\"argaddr\"), addrLbl2 = mkLabel(\"argaddr\"), addrLbl3 = mkLabel(\"argaddr\"); b.setZ(addrLbl1); b.setZ(addrLbl2); b.setZ(addrLbl3); b.add(mkLitRef(currArgOff), mkRef(negTmp.data), mkNxt()); b.subTo(negTmp.data, addrLbl1); b.subTo(negTmp.data, addrLbl2); b.subTo(negTmp.data, addrLbl3); b.add(mkLitRef(-currArgOff), mkRef(negTmp.data), mkNxt()); let retval = tmp.data; b.setZ(b.jmpTmp); b.subTo(retval, b.jmpTmp); b.add(addrLbl1, mkUninit(), addrLbl2, mkUninit(), mkNxt()); b.add(mkRef(b.jmpTmp), addrLbl3, mkUninit(), mkNxt()); currArgOff++; });"), exprs.emit_code("let retLabel = mkLabel(\"funccallret\"); let retLabelData = b.addData(mkRef(retLabel)); let retAddrSetLbl1 = mkLabel(\"funccall.rasl\"), retAddrSetLbl2 = mkLabel(\"funccall.rasl\"), retAddrSetLbl3 = mkLabel(\"funccall.rasl\"); b.setZ(retAddrSetLbl1); b.setZ(retAddrSetLbl2); b.setZ(retAddrSetLbl3); b.add(mkLitRef(1n), mkRef(negTmp.data), mkNxt()); b.subTo(negTmp.data, retAddrSetLbl1); b.subTo(negTmp.data, retAddrSetLbl2); b.subTo(negTmp.data, retAddrSetLbl3); b.add(mkLitRef(-1n), mkRef(negTmp.data), mkNxt()); b.setZ(b.jmpTmp); b.subTo(retLabelData, b.jmpTmp); b.add(retAddrSetLbl1, mkUninit(), retAddrSetLbl2, mkUninit(), mkNxt()); b.add(mkRef(b.jmpTmp), retAddrSetLbl3, mkUninit(), mkNxt());"), exprs.emit_code("let jmpEntryGetLbl = mkLabel(\"funccallgetjmp\"); let jmpEntryLbl = mkLabel(\"funccalljmp\"); b.setZ(jmpEntryGetLbl); b.setZ(jmpEntryLbl); b.subTo(negTmp.data, jmpEntryGetLbl); b.setZ(b.jmpTmp); b.add(jmpEntryGetLbl, mkUninit(), mkRef(b.jmpTmp), mkNxt()); b.subTo(b.jmpTmp, jmpEntryLbl); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), jmpEntryLbl, mkUninit()); b.add(retLabel); let getRetvalLbl = mkLabel(\"funccall.getretval\"); b.setZ(getRetvalLbl); b.subTo(negTmp.data, getRetvalLbl); b.add(mkLitRef(-2n), mkRef(getRetvalLbl), mkNxt()); b.setZ(b.jmpTmp); b.add(getRetvalLbl, mkUninit(), mkRef(b.jmpTmp), mkNxt()); b.setZ(retval); b.subTo(b.jmpTmp, retval); negTmp.release(); argTmps.forEach(t => t.release()); }")));
	define("function_call_by_pointer_arg", null, exprs.join(exprs.emit_code("{ let aTmp = b.tmp(); argTmps.push(aTmp); let retval = aTmp.data; "), exprs.def("expr"), exprs.emit_code(" }")));
	define("dynamic_call", null, exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.nonStaticFuncs.has(name)); assert(scope); let func = scope.nonStaticFuncs.get(name); let funcPtr = b.addData(mkRef(func.lbl));"), exprs.emit_code("const loadName = \"load\"; let loadScope = scopes.slice().reverse().find(scope => scope.variables.has(loadName)); if(!loadScope) throw new Error(\"Directly calling dynamic functions require static functions \'load\' and \'unload\'\"); let loadPtr = loadScope.variables.get(loadName).data;"), exprs.emit_code("const unloadName = \"unload\"; let unloadScope = scopes.slice().reverse().find(scope => scope.variables.has(unloadName)); if(!unloadScope) throw new Error(\"Directly calling dynamic functions require static functions \'load\' and \'unload\'\"); let unloadPtr = unloadScope.variables.get(unloadName).data;"), exprs.emit_code("let negPtrTmp = b.tmp(); let negPtr = negPtrTmp.data; b.setZ(negPtr); b.subTo(loadPtr, negPtr);"), exprs.emit_code("/*the arg*/ { let currArgOff = 3n; let addrLbl1 = mkLabel(\"argaddr\"), addrLbl2 = mkLabel(\"argaddr\"), addrLbl3 = mkLabel(\"argaddr\"); b.setZ(addrLbl1); b.setZ(addrLbl2); b.setZ(addrLbl3); b.add(mkLitRef(currArgOff), mkRef(negPtr), mkNxt()); b.subTo(negPtr, addrLbl1); b.subTo(negPtr, addrLbl2); b.subTo(negPtr, addrLbl3); b.add(mkLitRef(-currArgOff), mkRef(negPtr), mkNxt()); let retval = funcPtr; b.setZ(b.jmpTmp); b.subTo(retval, b.jmpTmp); b.add(addrLbl1, mkUninit(), addrLbl2, mkUninit(), mkNxt()); b.add(mkRef(b.jmpTmp), addrLbl3, mkUninit(), mkNxt()); }"), exprs.emit_code("let retLabel = mkLabel(\"funccallret\"); let retLabelData = b.addData(mkRef(retLabel)); let retAddrSetLbl1 = mkLabel(\"funccall.rasl\"), retAddrSetLbl2 = mkLabel(\"funccall.rasl\"), retAddrSetLbl3 = mkLabel(\"funccall.rasl\"); b.setZ(retAddrSetLbl1); b.setZ(retAddrSetLbl2); b.setZ(retAddrSetLbl3); b.add(mkLitRef(1n), mkRef(negPtr), mkNxt()); b.subTo(negPtr, retAddrSetLbl1); b.subTo(negPtr, retAddrSetLbl2); b.subTo(negPtr, retAddrSetLbl3); b.add(mkLitRef(-1n), mkRef(negPtr), mkNxt()); b.setZ(b.jmpTmp); b.subTo(retLabelData, b.jmpTmp); b.add(retAddrSetLbl1, mkUninit(), retAddrSetLbl2, mkUninit(), mkNxt()); b.add(mkRef(b.jmpTmp), retAddrSetLbl3, mkUninit(), mkNxt());"), exprs.emit_code("let jmpEntryGetLbl = mkLabel(\"funccallgetjmp\"); let jmpEntryLbl = mkLabel(\"funccalljmp\"); b.setZ(jmpEntryGetLbl); b.setZ(jmpEntryLbl); b.subTo(negPtr, jmpEntryGetLbl); b.setZ(b.jmpTmp); b.add(jmpEntryGetLbl, mkUninit(), mkRef(b.jmpTmp), mkNxt()); b.subTo(b.jmpTmp, jmpEntryLbl); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), jmpEntryLbl, mkUninit()); b.add(retLabel); let getRetvalLbl = mkLabel(\"funccall.getretval\"); b.setZ(getRetvalLbl); b.subTo(negPtr, getRetvalLbl); b.add(mkLitRef(-2n), mkRef(getRetvalLbl), mkNxt()); b.setZ(b.jmpTmp); b.add(getRetvalLbl, mkUninit(), mkRef(b.jmpTmp), mkNxt()); b.setZ(retval); b.subTo(b.jmpTmp, retval);"), exprs.emit_code("negPtrTmp.release(); let retvalBak = b.tmp(); b.copyTo(retval, retvalBak.data); "), exprs.def("_"), exprs.def("function_call_by_pointer"), exprs.emit_code("{ let negPtrTmp = b.tmp(); let negPtr = negPtrTmp.data; b.setZ(negPtr); b.subTo(unloadPtr, negPtr);"), exprs.emit_code("/*the arg*/ { let currArgOff = 3n; let addrLbl1 = mkLabel(\"argaddr\"), addrLbl2 = mkLabel(\"argaddr\"), addrLbl3 = mkLabel(\"argaddr\"); b.setZ(addrLbl1); b.setZ(addrLbl2); b.setZ(addrLbl3); b.add(mkLitRef(currArgOff), mkRef(negPtr), mkNxt()); b.subTo(negPtr, addrLbl1); b.subTo(negPtr, addrLbl2); b.subTo(negPtr, addrLbl3); b.add(mkLitRef(-currArgOff), mkRef(negPtr), mkNxt()); let retval = retvalBak.data; b.setZ(b.jmpTmp); b.subTo(retval, b.jmpTmp); b.add(addrLbl1, mkUninit(), addrLbl2, mkUninit(), mkNxt()); b.add(mkRef(b.jmpTmp), addrLbl3, mkUninit(), mkNxt()); }"), exprs.emit_code("let retLabel = mkLabel(\"funccallret\"); let retLabelData = b.addData(mkRef(retLabel)); let retAddrSetLbl1 = mkLabel(\"funccall.rasl\"), retAddrSetLbl2 = mkLabel(\"funccall.rasl\"), retAddrSetLbl3 = mkLabel(\"funccall.rasl\"); b.setZ(retAddrSetLbl1); b.setZ(retAddrSetLbl2); b.setZ(retAddrSetLbl3); b.add(mkLitRef(1n), mkRef(negPtr), mkNxt()); b.subTo(negPtr, retAddrSetLbl1); b.subTo(negPtr, retAddrSetLbl2); b.subTo(negPtr, retAddrSetLbl3); b.add(mkLitRef(-1n), mkRef(negPtr), mkNxt()); b.setZ(b.jmpTmp); b.subTo(retLabelData, b.jmpTmp); b.add(retAddrSetLbl1, mkUninit(), retAddrSetLbl2, mkUninit(), mkNxt()); b.add(mkRef(b.jmpTmp), retAddrSetLbl3, mkUninit(), mkNxt());"), exprs.emit_code("let jmpEntryGetLbl = mkLabel(\"funccallgetjmp\"); let jmpEntryLbl = mkLabel(\"funccalljmp\"); b.setZ(jmpEntryGetLbl); b.setZ(jmpEntryLbl); b.subTo(negPtr, jmpEntryGetLbl); b.setZ(b.jmpTmp); b.add(jmpEntryGetLbl, mkUninit(), mkRef(b.jmpTmp), mkNxt()); b.subTo(b.jmpTmp, jmpEntryLbl); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), jmpEntryLbl, mkUninit()); b.add(retLabel);"), exprs.emit_code("negPtrTmp.release(); retvalBak.release(); }}")));
	define("inline_call", null, exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.nonStaticFuncs.has(name)); assert(scope); let func = scope.nonStaticFuncs.get(name);"), exprs.emit_code("let argTmps = func.argNames.map(argName => b.tmp()); let argData = argTmps.map(tmp => tmp.data); let currArgI = 0;"), exprs.def("_"), exprs.str("("), exprs.optional(exprs.join(exprs.def("_"), exprs.def("inline_call_arg"), exprs.repeat(exprs.join(exprs.def("_"), exprs.str(","), exprs.def("_"), exprs.def("inline_call_arg"))))), exprs.def("_"), exprs.str(")"), exprs.emit_code("if(currArgI !== argData.length) throw new Error(\"Mismatched inline function arguments\"); func.generate(b, scopes, argData, retval); argTmps.forEach(tmp => tmp.release()); }")));
	define("inline_call_arg", null, exprs.join(exprs.emit_code("{ if(currArgI >= argData.length) throw new Error(\"Mismatched inline function arguments\"); let retval = argData[currArgI]; "), exprs.def("expr"), exprs.emit_code(" currArgI++; }")));
	define("value", null, exprs.choice(exprs.named("Integer", exprs.join(exprs.emit_code("b.add(mkRef(retval), mkRef(retval), mkNxt()); b.add(mkLitRef(-("), exprs.def("integer"), exprs.emit_code(")), mkRef(retval), mkNxt());"))), exprs.join(exprs.str("true_io_getch"), exprs.def("idend"), exprs.emit_code("b.add(mkLiteral(-1n), mkRef(retval), mkNxt());")), exprs.join(exprs.str("program_start_addr"), exprs.def("idend"), exprs.emit_code("b.copyTo(b.addData(mkRef(before_program_label)), retval);")), exprs.join(exprs.str("program_end_addr"), exprs.def("idend"), exprs.emit_code("b.copyTo(b.addData(mkRef(after_program_label)), retval);")), exprs.join(exprs.str("true_io_getch"), exprs.def("idend"), exprs.emit_code("b.add(mkLiteral(-1n), mkRef(retval), mkNxt());")), exprs.join(exprs.str("NULL"), exprs.def("idend"), exprs.emit_code("b.setZ(retval);")), exprs.named("TrueStaticIntsLiteral", exprs.join(exprs.emit_code("{ let origRetval = retval; let datas = []; "), exprs.str("static_ints"), exprs.def("idend"), exprs.def("_"), exprs.str("{"), exprs.def("_"), exprs.optional(exprs.join(exprs.emit_code("datas.push("), exprs.def("integer"), exprs.emit_code(");"), exprs.def("_"), exprs.repeat(exprs.join(exprs.str(","), exprs.def("_"), exprs.emit_code("datas.push("), exprs.def("integer"), exprs.emit_code(");"), exprs.def("_"))))), exprs.str("}"), exprs.emit_code(" let lenLiteral = mkLiteral(BigInt(datas.length)); let lbl = mkLabel(\"staticintlist.lbl\"); b.addData(lenLiteral, lbl, ...datas.map(num => mkLiteral(num))); let lblRef = b.addData(mkRef(lbl)); b.copyTo(lblRef, origRetval); }"))), exprs.named("ArrayLiteral", exprs.join(exprs.emit_code("{ let origRetval = retval; let datas = []; "), exprs.str("{"), exprs.def("_"), exprs.optional(exprs.join(exprs.emit_code("{ let retval = mkUninit(\"staticarrlit\"); datas.push(retval); "), exprs.def("expr"), exprs.emit_code(" }"), exprs.def("_"), exprs.repeat(exprs.join(exprs.str(","), exprs.def("_"), exprs.emit_code("{ let retval = mkUninit(\"staticarrlit\"); datas.push(retval); "), exprs.def("expr"), exprs.emit_code(" }"), exprs.def("_"))))), exprs.str("}"), exprs.emit_code(" let lenLiteral = mkLiteral(BigInt(datas.length)); let lbl = mkLabel(\"staticarrlit\"); b.addData(lenLiteral, lbl, ...datas); let lblRef = b.addData(mkRef(lbl)); b.copyTo(lblRef, origRetval); }"))), exprs.named("Variable", exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.variables.has(name)); if(!scope) throw new Error(\"Unknown variable: \"+name); "), exprs.emit_code("b.add(mkRef(retval), mkRef(retval), mkNxt(), mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkNxt(), mkRef(scope.variables.get(name).data), mkRef(b.jmpTmp), mkNxt(), mkRef(b.jmpTmp), mkRef(retval), mkNxt()); }"))), exprs.named("String", exprs.join(exprs.emit_code("{ let codePoints = [...("), exprs.def("string"), exprs.emit_code(")].map(ch => ch.codePointAt(0)); b.addData(mkLiteral(BigInt(codePoints.length))); /*str len before*/ let lbl = b.addData(mkLabel(\"stringliteral\")); b.addData(...codePoints.map(v => mkLiteral(BigInt(v)))); let lblRef = b.addData(mkRef(lbl)); b.copyTo(lblRef, retval); }"))), exprs.named("Char", exprs.join(exprs.str("\'"), exprs.not(exprs.str("\'")), exprs.not(exprs.str("\n")), exprs.emit_code("{ let ch = \""), exprs.def("char"), exprs.emit_code("\".codePointAt(0); b.setZ(retval); b.add(mkLitRef(-BigInt(ch)), mkRef(retval), mkNxt()); }"), exprs.str("\'"))), exprs.join(exprs.str("("), exprs.def("_"), exprs.def("expr"), exprs.def("_"), exprs.str(")"))));
	define("lvalue", null, exprs.choice(exprs.named("Deref", exprs.join(exprs.str("*"), exprs.def("_"), exprs.def("prefix_expr"))), exprs.named("Index", exprs.join(exprs.def("value"), exprs.repeat(exprs.join(exprs.not(exprs.join(exprs.def("_"), exprs.str("["), exprs.def("_"), exprs.def("expr"), exprs.def("_"), exprs.str("]"), exprs.def("_"), exprs.not(exprs.def("access_expr_op")))), exprs.def("_"), exprs.def("access_expr_op"))), exprs.def("_"), exprs.str("["), exprs.def("_"), exprs.emit_code("{ let origRetval = retval; { let tmp = b.tmp(); let retval = tmp.data; "), exprs.def("expr"), exprs.emit_code(" b.addTo(retval, origRetval); tmp.release(); }}"), exprs.def("_"), exprs.str("]"))), exprs.named("Variable", exprs.join(exprs.emit_code("{ let name = \""), exprs.emit_consumed(exprs.def("identifier")), exprs.emit_code("\"; let scope = scopes.slice().reverse().find(scope => scope.variables.has(name)); if(!scope) throw new Error(\"Unknown variable: \"+name); "), exprs.emit_code("let lbl = b.addData(mkLabel(\"lvaluevar\")); b.addData(mkRef(scope.variables.get(name).data)); b.copyTo(lbl, retval); }")))));
	define("PREPEND_CODE", null, exprs.emit_code("\n\nfunction assert(bool, msg = \"Assertion failed\") {\n\	if(!bool) throw new Error(msg);\n}\nfunction assert_bigint(value) {\n\	assert(typeof value === \"bigint\", \"Value is not bigint\");\n}\n\nlet nextLabelId = 0;\nfunction mkLabel(debugName = \"label\") {\n\	let instr = { type: \"label\", debugName: debugName + \"_\" + nextLabelId, id: nextLabelId, parentBlock: null };\n\	nextLabelId++;\n\	return instr;\n}\nfunction mkLiteral(num) { // Bigints are used in js\n\	assert_bigint(num);\n\	return { type: \"literal\", value: num, parentBlock: null };\n}\nfunction mkLitRef(num) {\n\	assert_bigint(num);\n\	return { type: \"literal_ref\", value: num, parentBlock: null };\n}\nfunction rewriteLitRefToRef(litRef, literal) {\n\	Object.assign(litRef, { type: \"ref\", value: literal });\n}\nfunction mkRelative(numOffset) {\n\	assert_bigint(numOffset);\n\	return { type: \"relative_ref\", value: numOffset, parentBlock: null };\n}\nfunction mkUninit(debugName) {\n\	return { type: \"uninit\", debugName: debugName ? \"uninit_\"+debugName : \"uninit\", parentBlock: null };\n}\nfunction mkRef(instr = null) {\n\	return { type: \"ref\", value: instr, parentBlock: null };\n}\nfunction mkNxt() {\n\	return mkRelative(1n);\n}\n\n\nlet tmpCurrI = 0;\nfunction Tmp(b) {\n\	this.data = b.addData(mkUninit(\"tmp_\"+tmpCurrI));\n\	tmpCurrI++;\n\	this.release = function() {\n\	\	b._releaseTmp(this);\n\	};\n}\nfunction Block(deoffsetConstants = true) {\n\	this.type = \"block\";\n\	this.parentBlock = null;\n\	this.deoffsetConstants = deoffsetConstants; // for global block\n\	this.instrs = [];\n\	this.data = [];\n\	this.true_header = []; // not deoffset and added at the start before deoffsetting, used for func args and stuff\n\n\	this.beforeLbl = null;\n\	this.afterLbl = null;\n\n\	let self = this;\n\	this.add = function(...instrs) {\n\	\	for(let instr of instrs) {\n\	\	\	instr.parentBlock = self;\n\	\	\	this.instrs.push(instr);\n\	\	}\n\	\	if(instrs.length === 1) return instrs[0];\n\	};\n\	this.prepend = function(...instrs) {\n\	\	for(let instr of instrs.slice().reverse()) {\n\	\	\	instr.parentBlock = self;\n\	\	\	this.instrs.unshift(instr);\n\	\	}\n\	\	if(instrs.length === 1) return instrs[0];\n\	};\n\	this.addData = function(...instrs) { // data is guaranteed to be added in order\n\	\	for(let instr of instrs) {\n\	\	\	this.data.push(instr);\n\	\	}\n\	\	if(instrs.length === 1) return instrs[0];\n\	};\n\n\	\n\	this.jmpTmp = this.addData(mkUninit(\"jmpTmp\"));\n\	this.availableTemps = [[]];\n\n\	this.tmp = function() {\n\	\	if(this.availableTemps.at(-1).length > 0) {\n\	\	\	return this.availableTemps.at(-1).pop();\n\	\	} else {\n\	\	\	return new Tmp(this);\n\	\	}\n\	};\n\	this._releaseTmp = function(tmp) {\n\	\	// TODO investigate if this can be uncommented\n\	\	///this.availableTemps.at(-1).push(tmp);\n\	};\n\	this.pushTemps = function() { // allows functions to have separate temps since at the function, temps in the caller will be released\n\	\	this.availableTemps.push([]);\n\	};\n\	this.popTemps = function() {\n\	\	this.availableTemps.pop();\n\	};\n\n\n\	let b = this;\n\	this.copyTo = function(dataA, dataB) {\n\	\	let tmp = b.tmp();\n\	\	b.add(mkRef(tmp.data), mkRef(tmp.data), mkNxt(), mkRef(dataB), mkRef(dataB), mkNxt());\n\	\	b.add(mkRef(dataA), mkRef(tmp.data), mkNxt(), mkRef(tmp.data), mkRef(dataB), mkNxt());\n\	\	tmp.release();\n\	};\n\	this.addTo = function(dataA, dataB) {\n\	\	let tmp = b.tmp();\n\	\	b.add(mkRef(tmp.data), mkRef(tmp.data), mkNxt());\n\	\	b.add(mkRef(dataA), mkRef(tmp.data), mkNxt(), mkRef(tmp.data), mkRef(dataB), mkNxt());\n\	\	tmp.release();\n\	};\n\	this.subTo = function(dataA, dataB) {\n\	\	b.add(mkRef(dataA), mkRef(dataB), mkNxt());\n\	};\n\	this.setZ = function(dataA) {\n\	\	b.add(mkRef(dataA), mkRef(dataA), mkNxt());\n\	};\n}\nfunction Variable(name, instr) {\n\	assert(name);\n\	assert(instr);\n\	this.name = name;\n\	this.data = instr;\n}\nfunction InlineFunc() {\n\	this.name = null;\n\	this.argNames = [];\n\	this.generate = null;\n}\nfunction DynamicFunc() {\n\	this.name = null;\n\	this.lbl = null;\n}\nfunction Scope() {\n\	this.variables = new Map(); // variable by name\n\	this.nonStaticFuncs = new Map();\n\	this.loopBreakLbl = null; // null if not a loop\n\	this.loopContinueLbl = null;\n\	this.funcRetvalData = null;\n\	this.funcRetLbl = null;\n\n\	this.makeVar = function(name, instr) {\n\	\	let variable = new Variable(name, instr);\n\	\	if(this.variables.has(name) || this.nonStaticFuncs.has(name)) throw new Error(\"Duplicate variable or function in same scope: \"+name);\n\	\	this.variables.set(name, variable);\n\	\	return variable;\n\	};\n\	this.makeFunc = function(name, func) {\n\	\	func.name = name;\n\	\	if(this.variables.has(name) || this.nonStaticFuncs.has(name)) throw new Error(\"Duplicate variable or function in same scope: \"+name);\n\	\	this.nonStaticFuncs.set(name, func);\n\	\	return func;\n\	};\n}\n\nlet before_program_label = mkLabel(\"after_gen_label\"); // label that is appended to after generated stuff, this is to be used by malloc\nlet after_program_label = mkLabel(\"after_gen_label\"); // label that is appended to after generated stuff, this is to be used by malloc\n\nfunction malloc(b, retval, size) {\n\	const tmps = []; const tmp = () => { let t = b.tmp(); tmps.push(t); return t.data };\n\	let afterLbl = mkLabel(\"malloc.after\"), sizeLeq0Lbl = mkLabel(\"malloc.sizeleq0\");\n\	b.add(mkLitRef(0n), mkRef(size), mkRef(sizeLeq0Lbl));\n\	let origPtr = b.addData(mkRef(after_program_label));\n\	let origNegSize = tmp(); b.setZ(origNegSize); b.subTo(size, origNegSize);\n\	let negPtr = tmp(); b.setZ(negPtr); b.subTo(origPtr, negPtr);\n\	let leqLbl = mkLabel(\"malloc.leq\"), enoughSizeLbl = mkLabel(\"malloc.enough\"), endOfMemLbl = mkLabel(\"malloc.endofmem\");\n\	// check\n\	let checkLbl = b.add(mkLabel(\"malloc.check\"));\n\	let negData = tmp(); let dataGetLbl = mkLabel(); b.setZ(negData); b.setZ(dataGetLbl); b.subTo(negPtr, dataGetLbl); b.add(dataGetLbl, mkUninit(), mkRef(negData), mkNxt());\n\	let data = tmp(); b.setZ(data); b.subTo(negData, data);\n\	b.add(mkLitRef(0n), mkRef(data), mkRef(leqLbl));\n\	// data > 0 (mem is used)\n\	b.subTo(data, negPtr); b.add(mkLitRef(1n), mkRef(negPtr), mkRef(checkLbl));\n\	// data <= 0\n\	b.add(leqLbl);\n\	// check if size <= -data-1 (if size+data+1 <= 0)\n\	let sizeCheckTmp = tmp(); b.setZ(sizeCheckTmp);\n\	b.subTo(origNegSize, sizeCheckTmp); b.subTo(negData, sizeCheckTmp); b.add(mkLitRef(-1n), mkRef(sizeCheckTmp), mkRef(enoughSizeLbl));\n\	// not enough size or perhaps is at end of memory\n\	b.add(mkLitRef(0n), mkRef(negData), mkRef(endOfMemLbl)); // check if end of memory\n\	// not enough size\n\	b.subTo(negData, negPtr); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(checkLbl));\n\	// end of mem\n\	b.add(endOfMemLbl);\n\	{\n\	\	let a = mkLabel(\"a\");\n\	\	b.setZ(a); b.subTo(negPtr, a);\n\	\	b.add(mkRef(origNegSize), a, mkUninit(), mkNxt());\n\	\	b.add(mkLitRef(1n), mkRef(negPtr), mkNxt());\n\	\	b.setZ(retval); b.subTo(negPtr, retval); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl));\n\	}\n\	// size <= 0\n\	b.add(sizeLeq0Lbl);\n\	let zeroPtr = b.addData(mkLitRef(0n)); b.copyTo(zeroPtr, retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt()); b.add(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(afterLbl));\n\	// enough size\n\	b.add(enoughSizeLbl);\n\	{ // set *ptr=len, set retval\n\	\	let [a, bb, c] = [mkLabel(), mkLabel(), mkLabel()];\n\	\	b.setZ(a); b.add(mkRef(negPtr), mkRef(a), mkNxt()); b.setZ(bb); b.add(mkRef(negPtr), mkRef(bb), mkNxt()); b.setZ(c); b.add(mkRef(negPtr), mkRef(c), mkNxt());\n\	\	b.add(a, mkUninit(), bb, mkUninit(), mkNxt()); b.add(mkRef(origNegSize), c, mkUninit(), mkNxt());\n\	\	b.setZ(retval); b.subTo(negPtr, retval); b.add(mkLitRef(-1n), mkRef(retval), mkNxt());\n\	}\n\	{ // restructure remaining data\n\	\	b.add(mkLitRef(1n), mkRef(negPtr), mkNxt()); b.subTo(size, negPtr);\n\	\	let remaining = tmp(); // remaining # of ints = -data-1 - length\n\	\	b.setZ(remaining); b.subTo(data, remaining); b.add(mkLitRef(1n), mkRef(remaining), mkNxt()); b.subTo(size, remaining);\n\	\	b.add(mkLitRef(0n), mkRef(remaining), mkRef(afterLbl)); // don\'t do anything if remaining == 0\n\	\	// otherwise set (new) negPtr to -(remaining+1-1) = -remaining\n\	\	let [a, bb, c] = [mkLabel(), mkLabel(), mkLabel()];\n\	\	b.setZ(a); b.add(mkRef(negPtr), mkRef(a), mkNxt()); b.setZ(bb); b.add(mkRef(negPtr), mkRef(bb), mkNxt()); b.setZ(c); b.add(mkRef(negPtr), mkRef(c), mkNxt());\n\	\	b.add(a, mkUninit(), bb, mkUninit(), mkNxt()); b.add(mkRef(remaining), c, mkUninit(), mkNxt());\n\	}\n\	// after\n\	b.add(afterLbl);\n\	tmps.forEach(t => t.release());\n}\nfunction free(b, ptr) {\n\	const tmps = []; const tmp = () => { let t = b.tmp(); tmps.push(t); return t.data };\n\	let afterLbl = mkLabel(\"malloc.after\");\n\	b.add(mkLitRef(1n), mkRef(ptr), mkNxt());\n\	let negPtr = tmp(); b.setZ(negPtr); b.subTo(ptr, negPtr);\n\	let len = tmp(); let negLen = tmp(); b.setZ(len); b.setZ(negLen); let getLenLbl = mkLabel(\"free.getlen\"); b.setZ(getLenLbl); b.subTo(negPtr, getLenLbl); b.add(getLenLbl, mkUninit(), mkRef(negLen), mkNxt()); b.subTo(negLen, len);\n\	// if len <= 0, goto afterLbl since points to shared when len==0 when malloc(size=0) used\n\	b.add(mkLitRef(0n), mkRef(len), mkRef(afterLbl));\n\	// set len to negative\n\	{\n\	\	let subtractBy = tmp(); // len+len+1\n\	\	b.setZ(subtractBy); b.subTo(negLen, subtractBy); b.subTo(negLen, subtractBy); b.add(mkLitRef(-1n), mkRef(subtractBy), mkNxt());\n\	\	let a = mkLabel();\n\	\	b.setZ(a); b.subTo(negPtr, a); b.add(mkRef(subtractBy), a, mkUninit(), mkNxt());\n\	}\n\	// TODO merge possibly next and possibly previous free areas\n\	// after\n\	b.add(afterLbl);\n\	tmps.forEach(t => t.release());\n}\n\nlet b = new Block(false); // global block\nb.beforeLbl = before_program_label;\nb.afterLbl = after_program_label;\nlet scopes = [new Scope()];\n"));
	define("APPEND_CODE", null, exprs.emit_code("\n\n// exit\nb.add(mkLitRef(0n), mkLitRef(0n), mkLiteral(-1n));\n\n\nconst json_debug_str_used = new Set();\nconst json_debug_str = JSON.stringify(b, (key, value) => typeof value === \"bigint\" ? \"\"+value : typeof value === \"object\" && value !== null ? (json_debug_str_used.has(value) ? \"<cyclic value>\" : (json_debug_str_used.add(value), value)) : value, 2);\n//console.log(\"resulting structure:\", json_debug_str);\nconsole.log(\"structure\", b);\n\n\n// Now we assemble the structure\n\n// Resolve literal refs to refs(literal) and deoffset constants and data\nfunction prepare_block(b) {\n\	const blockEntryLabel = b.prepend(mkLabel(\"block_entrypoint\"));\n\n\	// prepend data in order\n\	for(let instr of b.data.slice().reverse()) {\n\	\	instr.parentBlock = b;\n\	\	b.prepend(instr);\n\	}\n\	b.data = [];\n\n\	// resolve litrefs\n\	let literals_used = new Map();\n\n\	for(let instr of b.instrs) {\n\	\	assert(instr.type, \"instr does not have .type, instr is not an instr\");\n\	\	if(instr.type === \"ref\") assert(instr.value.type, \"ref value does not have .type, ref value is not an instr\");\n\	\	if(instr.type === \"block\") {\n\	\	\	prepare_block(instr);\n\	\	} else if(instr.type === \"literal_ref\") {\n\	\	\	let literal;\n\	\	\	if(literals_used.has(instr.value)) literal = literals_used.get(instr.value);\n\	\	\	else {\n\	\	\	\	literal = mkLiteral(instr.value);\n\	\	\	\	literals_used.set(instr.value, literal);\n\	\	\	}\n\	\	\	rewriteLitRefToRef(instr, literal);\n\	\	}\n\	}\n\	for(let literal of literals_used.values()) { // prepend literals\n\	\	b.prepend(literal);\n\	}\n\	\n\	b.prepend(mkRef(b.jmpTmp), mkRef(b.jmpTmp), mkRef(blockEntryLabel));\n\	b.true_header.forEach(instr => assert(instr.type !== \"literal\" && instr.type !== \"literal_ref\"));\n\	if(b.deoffsetConstants) {\n\	\	let instrsWithinMe = [];\n\	\	function walk(b) {\n\	\	\	for(let instr of b.instrs) {\n\	\	\	\	if(instr.type === \"block\") walk(instr);\n\	\	\	\	else instrsWithinMe.push(instr);\n\	\	\	}\n\	\	}\n\	\	instrsWithinMe.unshift(...b.true_header);\n\	\	walk(b);\n\	\	let deoffsetVal = mkLiteral(0n);\n\	\	let deoffset = [mkRelative(3n), mkRelative(2n), mkRelative(3n), mkUninit(), deoffsetVal];\n\	\	for(let instr of instrsWithinMe) {\n\	\	\	if(instr.type === \"literal\" || (instr.type === \"ref\" && !instrsWithinMe.includes(instr.value))) {\n\	\	\	\	assert(!b.true_header.includes(instr), \"true_header assertion failed\");\n\	\	\	\	deoffset.push(mkRef(deoffsetVal), mkRef(instr), mkNxt());\n\	\	\	}\n\	\	}\n\	\	b.prepend(...deoffset);\n\	}\n\	// literals and external refs wont be deoffset from here on\n\n\	b.prepend(...b.true_header);\n\n\	if(b.beforeLbl) b.prepend(b.beforeLbl); // before and after labels\n\	if(b.afterLbl) b.add(b.afterLbl);\n}\nprepare_block(b);\n\n// Calculate addresses\nlet curr_address = 0n;\nfunction calc_addresses_block(b) {\n\n\	for(let instr of b.instrs) {\n\	\	instr.address = curr_address;\n\	\	if(instr.type === \"block\") {\n\	\	\	calc_addresses_block(instr);\n\	\	} else if(instr.type !== \"label\") curr_address += 1n;\n\	}\n\n\	return curr_address;\n}\ncalc_addresses_block(b);\n\n// Generate subleq\n\nfunction gen_subleq_block(b) {\n\	assert(b.data.length === 0);\n\	const subleq = [];\n\	\n\	for(let instr of b.instrs) {\n\	\	if(instr.type === \"label\") ; //pass\n\	\	else if(instr.type === \"literal\") subleq.push(instr.value);\n\	\	else if(instr.type === \"literal_ref\") throw new Error(\"literal_ref present in gen_subleq_block\");\n\	\	else if(instr.type === \"relative_ref\") subleq.push(instr.address + instr.value);\n\	\	else if(instr.type === \"uninit\") subleq.push(69n);\n\	\	else if(instr.type === \"ref\") {\n\	\	\	if(instr.value.address == null) {\n\	\	\	\	console.log(\"ref pointing to instr with uncalculated address\", instr, instr.value);\n\	\	\	\	throw new Error(\"ref pointing to instr with uncalculated address\");\n\	\	\	}\n\	\	\	subleq.push(instr.value.address);\n\	\	} else if(instr.type === \"block\") subleq.push(...gen_subleq_block(instr));\n\	}\n\n\	return subleq;\n}\nconst subleq = gen_subleq_block(b);\n\nconsole.log(\"subleq\", subleq);\nreturn subleq.map(v => v.toString()).join(\" \");\n"));

	const fmt_rowcol = (pos) => (filename !== null ? filename+":" : "") + code.slice(0, pos).split("\n").length + ":" + (code.slice(0, pos).split("\n").at(-1).length+1);

	const result = exprs.join(exprs.def(startDefName), exprs.eof())(0);
	if(result.matched) {
		return new ASTNode(startDefName, result.results, code, 0, code.length);
	} else {
		if(furthest.entered.name !== null && furthest.pos > furthest.entered.start && furthest.exited.name !== null && furthest.exited.end === furthest.pos) throw new Error(fmt_rowcol(furthest.pos) + " Invalid syntax after " + visualNames[furthest.exited.name] + " in " + visualNames[furthest.entered.name]);
		if(furthest.entered.name !== null && furthest.pos > furthest.entered.start) throw new Error(fmt_rowcol(furthest.pos) + " Invalid syntax in " + visualNames[furthest.entered.name]);
		if(furthest.exited.name !== null) throw new Error(fmt_rowcol(furthest.pos) + " Invalid syntax after " + visualNames[furthest.exited.name]);
		throw new Error(fmt_rowcol(furthest.pos) + " Invalid syntax");
	}
}